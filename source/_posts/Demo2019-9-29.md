---
title: JVM内存模型与GC算法策略
date: 2019-09-29 16:09:57
top: true
tags: [JVM内存模型,GC]
categories: [JVM]
---

## JVM Run-Time Data Area 运行时数据区

在学习后文，先展示 JVM RunTime Data Area大致布局图和JVM Stacks图

 {% asset_img 07.png  %}

 {% asset_img 08.png  %}

### JVM Stacks   Java虚拟机栈

首先要知道，栈是操作系统内核为某个进程或者线程建立的存储区域，它保存着一个线程中的方法的调用状态，它

具有先进后出的特性。在栈中的数据大小与生命周期都是**确定**的，在方法执行完成后退出栈后，它的生命周期也就

结束了。

Java虚拟机栈是JVM建立的，根据《深入理解Java虚拟机》，JVMS(虚拟机栈)是**线程私有的**。它的生命周期与线程相同

**注意：Java中每个方法对应一个Frame(栈帧)**，每个Frame中都有Local Variables(局部变量表)，Operand Satcks(操作数栈)，Dynamic Linking(动态链接),Return Address(方法出口)。每一个方法从调用到到执行完毕，就是一个Frame在JVMS

中入栈到出栈的过程。

####  图解Frame中方法的一次执行过程

```java
 public static void main(String[] args) {
        int i = 10;
    }
```

这一段代码发生什么？

首先看Frame中Local Variables和Operand Stack的指令图

 {% asset_img 01.png  %}

{% asset_img 02.png  %}

- 由图看出 main线程栈中经历了 ：

  - 1.指令 ipush 把100 压如**操作数栈**，istore 1 把栈顶元素放到**局部变量表**中索引为 1 的区域，注意：局部变量表有两个参数，**args 和 i**

    {% asset_img 03.png  %}

```java
 public void add(int a,int b){
        int c= a+b;
    }
```

还是首先看Frame中Local Variables和Operand Stack的指令图

{% asset_img 04.png  %}

{% asset_img 05.png  %}

- add 线程栈经历了：

  - 1.指令 iload1 iload2 把提前已经在 a 和 b 的值从 操作数栈中放到 **局部变量表中**中索引为 1  2的区域，iadd 把a和b相加放到局部变量表的栈顶 ，istore3 把 7 弹出放到 c 中 return 结束

    {% asset_img 06.png  %}

### PC Register 程序计数器

程序计数器是一块小的内存空间，它的功能：**记录当前线程执行地址**，**每一个线程都有一个PC 寄存器，即它为线程私有**。

- 为什么需要PC计数器：

  - Java虚拟机的多线程是通过**线程轮流切换**并分配处理器执行时间实现的。因此，为了**线程切换后能恢复到正确的执行位置**，每个线程都需要一个独立的PC计数器。

### Native Method Area本地方法栈

用来调用其他语言的本地方法，比如C / C++ 写得本地代码，这些方法在本地方法栈执行，而不会再Java栈中执行。**它也是线程私有的**。

### Java Head 

Java虚拟机管理的内存中最大的一块，**是所有线程共享的**，几乎所有的对象实例都在这里分配。（有些小的对象有可能不在这分配，后面再说）。Java堆是垃圾收集器管理的主要区域。从内存回收角度看：现在的收集器基本都采用**分代收集算法**，所以Java堆还可以被分为：新生代和老年代：在细致-> Eden区  两个Survivor区（1:1） Tenured(终身区)，关于垃圾回收，随后说。

### Method Area 方法区

与Java堆一样，是**线程共享的**，用于存储已被Java虚拟机加载的类信息   常量   静态变量   编译器编译后的代码。JVM运行时，类加载器子系统将会提取 class 文件里的类信息，并将其放到Method Area中，

#### RunTime Constant Pool 运行时常量池

Method Area中的一部分，用于存放编译期生成的各种字面量和符号引用。除了保存 Class 文件中描述的符号引用外，还会把翻译出来的**直接引用**也存储在运行时的常量池中。关于运行时常量池的详解。在学习完类加载顺序后再说明。

## GC算法分配策略

首先看一张Heap中从内存回收角度的分布图：

{% asset_img 09.png  %}

现在来解释：

- 首先 eden 区和 Survivor区比例为 8：1:1，至于为何，应该是经过多次试验，这样分配最好吧，后期可以调参，新生代产生的垃圾比较多，Old 老年代产生的相对少。所以新生代多使用 Copying 复制垃圾回收算法。老年代多使用 Mark Compact 标记整理算法。至于为何。看下文！
### GC 过程

- 当 new 了一个对象。如果JVM检测到它**“ 很大 ”**，何为大对象：需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组，它们会被直接**放到Old老年代**。

- 在正常的情况下：

  - 对象**优先先放到Eden**,如果不需要它了，GC，如果发现有的引用还指向它。把这个对象 Copy 到Survivor区中的S0  S1中的一个，比如S0
  
  - GC开始 如果发现S0中这个对象不存在了，直接回收，如果依然存在，在 Copy 到 S1 中
  
  - 在来一次 GC ,发现它在 S1 中还存在(需要生存),又 Copy 到 S0 中，循环往复 **15次**，发现对象一直存在，直接放到**Old**区。
  
### 什么是 垃圾对象（如何确定它）
一句话，未来不会再被用的对象，如何确定它？

- 引用计数：

  对象会有一个**对象头**，有一个引用计数器，默认为 0 ，来一个引用，计数器加 1 ，当引用失效，计数器就减 1 ，当减为 0 时，为 垃圾 ——>GC;

  - 缺点：很明显，它很容易因为对象之间相互循环引用，最终造成**Memory Leak**.
  
- Root Searching 根搜索 正向可达

  - Searching from the roots instance

  - Which instance is roots instance?

​              JVM Stacks引用的对象     Native Method Stacks 引用的对象      RunTime Constant Pool 常量池中引用引用的对象   Static reference in method area 引用的对象

- 实现：

  根据这些跟对象传出的引用去找，看有什么对象可以找到，能找到(可达）的都不是垃圾，反之是垃圾

### 如何清除垃圾

- 1.Mark-Sweep 标记-清除：

  首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

  - 它很简单，但是有两点不足：一是**效率不高，二是带来了内存碎片化问题**
  
- 2.Copying 复制算法

    事先准备两块大小相等的内存，每次只使用一块，当这一块使用完了，将还存活的对象**复制**到另一块中，在清除已使用过的内存空间。很明显，**内存浪费**。

- 3.Mark-Compact 标记-整理
  
  {% asset_img 10.png  %}
  
  标记过程与 " 标记 清除" 一样，但后续中：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
## 再谈Java对象的分配

- 1.一个小的对象，在JDK1.8之后，会首先放到栈上

**放到栈上的对象具备以下特征：1.线程私有化的  2.无逃逸（一个对象只有这个这个方法用，其他方法没有用）3.支持标量替换**。

栈上分配的好处：**自动回收（弹栈）**。

- 2.栈上不能分配了，或者它逃逸了，那么会被**分配到线程本地TLAB(位于堆的Eden区，占用Eden的 1% 的空间)，它的优点在于：多线程下，小对象不用竞争eden区就可以申请空间，提高了效率。**
- 3.看是否是 大对象，是的话，直接 Old 老年代。
- 4.不是，进入Eden

 





​    







