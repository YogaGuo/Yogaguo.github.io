---
title: 一致性哈希算法的原理
date: 2019-11-03 18:42:54
tags: 一致性哈希算法
categories: 算法
top: true
---

### 一种常见的场景：

 工程师经常使用**服务器集群**来设计和实现**数据缓存**，经典的策略是：

   - 无论是添加，查询还是删除数据，都先将数据的 id 号通过哈希函数转换为一个哈希值，记为 key.

   - 如果现在机器有 N 台，则计算 key%N 的值，这个值就是该数据所属的机器编号，无论是添加 删除 还是查询，都只是在这台机器上进行

请注意，这种缓存策略可能带来一个问题：

- 如果现在是双十一，我要**加机器**来满足负载，或者是有时候要**去掉**几台机器，N变化了，所有的数据都不得不根据 id 重新计算一遍哈希值，并将哈希值对新的机器取模，然后就是大规模的数据迁移。这个代价很高！


为了解决这个问题，引入**一致性哈希算法**，这是一种很好的数据缓存设计方案。

假设所有的数据的 id 通过哈希函数转换成的哈希范围是 2^23,范围在 0 ~（2^23）-1 的数字空间中。现在我们可以将这些数字头尾相连。想象成一个闭合的环形，那么一个数据在计算出哈希值之后就会认为对应到环中的一个位置。

接下来，想象有三台机器通过自己的 ip 计算出来后也在这样的一个环中的各自位置上，那么一条数据如何确定归属那台机器？

- 首先把数据的 id 用哈希函数计算出哈希值，并映射到环上相应位置。

- 然后**顺时针**寻找离自己位置最近的机器，这台机器就是该数据的归属。

  {% asset_img 1.png %}

在图 6-4中，data1根据其 id 计算出的哈希值为 key1 ,顺时针的第一台机器是 machine2,所以data1归属；同理，data2归属 machine3,data3和data4归属 machine1.

增加机器时的处理：假设有两台机器（m1 m2）和三个数据（data1 data2 data3）,数据和机器在环上的结构图 6-5

如果此时想加入新的机器 m3 ,同时算出机器 m3 的 id 在 m1和 m2 右半边的环上，那么发生 的变化如图 6-6

{% asset_img 2.png  %}

在没有添加 m3 之前，从 m1 到现在 m3 位置上的这一段是 m2 掌管的一部分；添加 m3 之后统一归属 m3 ,同时要把这一段的数据从 m2 迁移到 m3 上。由此可见，添加机器时的调整是比较小的。在删除机器时也一样。只要把要删除机器中的机器全部迁移到顺时针找到的机器中。

### 机器负载不均的处理

 根据哈希性质，它的离散型是随着输入域量的增加变好的，实现几乎均匀分布。如果机器较少，有可能造成机器在整个环上的分布不均匀，从而导致机器之间的负载不均衡。比如。图6-7 所示的两台机器，m1可能比m2 面临更大的负载。

{% asset_img 3.png  %}

为了解决这种问题，一致性哈希算法引入了**虚拟节点机制**,即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。

{% asset_img 4.png  %}

具体做法可以在机器 ip 或 hostname 的后面增加编号或端口号来实现。以图6-7的看，可以为每台机器计算两个节点，分别为m1-1 ,m1-2和m2-1 m2-2的哈希值，于是就形成了四个虚拟节点，这样节点数就变多了，根据哈希函数的性质，平衡性自然会变好。

当某一条数据计算出归属于m1-2时，再根据表的跳转，数据将最终归属于实际的m1机器。

