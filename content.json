{"meta":{"title":"小鱼儿的技术博客","subtitle":"走出生活舒适圈","description":"技术博客，Java编程，算法学习","author":"小鱼儿","url":"https://Yogaguo.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-09-10T12:51:59.000Z","updated":"2019-10-04T11:38:59.947Z","comments":true,"path":"categories/index.html","permalink":"https://Yogaguo.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-11-26T11:43:08.000Z","updated":"2020-02-12T04:52:46.617Z","comments":true,"path":"about/index.html","permalink":"https://Yogaguo.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-02-12T04:54:51.935Z","comments":true,"path":"contact/index.html","permalink":"https://Yogaguo.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-10T12:53:16.000Z","updated":"2019-10-04T11:38:59.959Z","comments":true,"path":"tags/index.html","permalink":"https://Yogaguo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring基础学习02","slug":"Demo2020-02-13blog","date":"2020-02-14T11:30:40.000Z","updated":"2020-05-31T08:05:27.943Z","comments":true,"path":"2020/02/14/Demo2020-02-13blog/","link":"","permalink":"https://Yogaguo.github.io/2020/02/14/Demo2020-02-13blog/","excerpt":"前言Spring基础学习01 先用上篇文章学过的基于xml的IOC完成简单的数据库操作 搭建环境不展示 项目结构如下图 Maven工厂构建spring开发环境 ,导入坐标 &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>5.2.1.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>commons-dbutils&lt;/groupId> &lt;artifactId>commons-dbutils&lt;/artifactId> &lt;version>1.4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.39&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>5.2.1.RELEASE&lt;/version> &lt;/dependency> &lt;/dependencies>","text":"前言Spring基础学习01 先用上篇文章学过的基于xml的IOC完成简单的数据库操作 搭建环境不展示 项目结构如下图 Maven工厂构建spring开发环境 ,导入坐标 &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>5.2.1.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>commons-dbutils&lt;/groupId> &lt;artifactId>commons-dbutils&lt;/artifactId> &lt;version>1.4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.39&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>5.2.1.RELEASE&lt;/version> &lt;/dependency> &lt;/dependencies> 核心代码 业务层实现类 package com.Yogaguo.service.impl; import com.Yogaguo.dao.IAccountDao; import com.Yogaguo.domain.Account; import com.Yogaguo.service.IAccountService; import java.util.List; public class AccountServiceImpl implements IAccountService { private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) { this.accountDao = accountDao; } public List&lt;Account> findAllAccount() { return accountDao.findAllAccount(); } public Account findAccouuntById(int id) { return accountDao.findAccouuntById(id); } public void saveAccount(Account account) { accountDao.saveAccount(account); } public void updateAccount(Account account) { accountDao.updateAccount(account); } public void deleteAccount(int id) { accountDao.deleteAccount(id); } } Dao层实现类 package com.Yogaguo.dao.ipml; import com.Yogaguo.dao.IAccountDao; import com.Yogaguo.domain.Account; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.BeanHandler; import org.apache.commons.dbutils.handlers.BeanListHandler; public class AccountDaoImpl implements IAccountDao { private QueryRunner runner; public void setRunner(QueryRunner runner) { this.runner = runner; } public List&lt;Account> findAllAccount() { try { return runner.query(\"select * from user\",new BeanListHandler&lt;Account>(Account.class)); } catch (SQLException e) { throw new RuntimeException(e); } } public Account findAccouuntById(int id) { try { return runner.query(\"select * from user where id=?\",new BeanHandler&lt;Account>(Account.class),id); } catch (SQLException e) { throw new RuntimeException(e); } } public void saveAccount(Account account) { try { runner.update(\"insert into user(username,password)values(?,?)\",account.getUsername(),account.getPassword()); } catch (SQLException e) { e.printStackTrace(); } } public void updateAccount(Account account) { try { runner.update(\"update user set username=?,password=? where id=?\",account.getUsername(),account.getPassword(),account.getId()); } catch (SQLException e) { e.printStackTrace(); } } public void deleteAccount(int id) { try { runner.update(\"delete from user where id=?\",id); } catch (SQLException e) { e.printStackTrace(); } } } XML配置 &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!--配置Service对象--> &lt;bean id=\"accountService\" class=\"com.Yogaguo.service.impl.AccountServiceImpl\"> &lt;!--注入dao对象--> &lt;property name=\"accountDao\" ref=\"accountDao\">&lt;/property> &lt;/bean> &lt;!--配置Dao对象--> &lt;bean id=\"accountDao\" class=\"com.Yogaguo.dao.ipml.AccountDaoImpl\"> &lt;property name=\"runner\" ref=\"runner\">&lt;/property> &lt;/bean> &lt;!--配置runner对象--> &lt;bean id=\"runner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"> &lt;!--注入数据源--> &lt;constructor-arg name=\"ds\" ref=\"datasource\">&lt;/constructor-arg> &lt;/bean> &lt;!--配置数据源--> &lt;bean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;!--连接数据库的必备信息--> &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\">&lt;/property> &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/day14\">&lt;/property> &lt;property name=\"user\" value=\"root\">&lt;/property> &lt;property name=\"password\" value=\"123456\">&lt;/property> &lt;/bean> &lt;/beans> 测试 /** * 使用Junit单元测试，测试配置 */ public class AccountServiceTest { /** * 获取容器 */ @Test public void testfindAll() { /** * 获取容器 */ ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //得到业务层对象 IAccountService accountService =(IAccountService) ac.getBean(\"accountService\"); List&lt;Account> allAccount = accountService.findAllAccount(); for(Account account : allAccount){ System.out.println(account); } } 基于注解的 IOC 配置 学习基于注解的 IoC 配置须清楚，即注解配置和 xml 配置要实现的功能都是一样 ，的，都是要降低程序间的耦合。只是配置的形式不一样 注意 当我们使用注解注入时，set 方法不用写 基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束 约束地址 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!--告诉spring，在创建容器时，要扫描的包，配置所需的标签不是在beans约束里，而是在一个 名称为context名称空间和约束中 --> &lt;context:component-scan base-package=\"com.item\">&lt;/context:component-scan> &lt;/beans> 常用注解介绍 账户层实现类曾经的xml配置 &lt;bean id=&quot;accountService&quot; class=&quot;com.item.service.AccountServiceImpl&quot; scope=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt; &lt;property name=&quot;&quot; value=&quot;&quot;/ ref=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 用于创建对象的注解 它们的作用就和在xml中编写标签一样 @Component: 作用：把当前类存入spring容器中 属性：value,用于指定bean的id,当我们不写时，默认值为当前类型，且首字母改写 @Service ：一般用于表现层 @Controller：一般用于业务层 @Repository :一般用于持久层 以上三个注解的作用和属性和@Component一样，它们三个是spring 提供的明确的三层使用的注解使我们的三层对象更加清晰 用于注入数据的注解它们的作用就和在中编写标签一样@Autowired:自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注 入成功，出现的位置可以在变量上，也可以在方法上 ,注意：在使用注解时，set方法就不是必须的了 @Qualifier在按照类型注入的基础上，在按照名称注入，在给类成员注入时，不能单独使用!!!但是在给方法参数注入时可以属性：value 用于指定注入bean的id @Resource直接按照bean的id注入，可以独立使用。属性：name 用于指定注入bean的id 以上三个注解都只能注入其他bean类型的数据，而基本类型和String类型都无法使用注解实现另外，集合类型的注入只能通过xml实现 代码示例 业务层@Component public class AccountServiceImpl implements IAccountService { @Autowired private IAccountDao accountDao; public void saveAccount() { accountDao.saveAccount(); } } Dao 层 package com.item.dao; import org.springframework.stereotype.Repository; @Repository(\"accountDao\") public class AccountDaoImpl implements IAccountDao { public void saveAccount() { System.out.println(\"保存了账户\"); } } 测试 public static void main(String[] args) { /** * 获取核心容器对象 */ ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); /** * 根据id获取Bean对象 */ IAccountService as =(IAccountService) ac.getBean(\"accountServiceImpl\"); as.saveAccount(); } 运行结果 保存了账户 @Value直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。属性：name：指定 bean 的 id。 spring 的纯注解配置 基于注解的 IoC 配置已经完成,我们依然离不开 spring 的 xml 配 置文件，那么能不能不写这个 bean.xml，所有配置都用注解来实现呢？ 我们发现，之所以我们现在离不开 xml 配置文件，是因为我们有一句很关键的配置： &lt;context:component-scan base-package=*”com.itheima”*&gt; 如果他要也能用注解配置，那么我们就离脱离 xml 文件又进了一步。 新注解说明 @Configuration用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用 AnnotationApplicationContext(有@Configuration 注解的类.class)。属性：value:用于指定配置类的字节码 @ComponentScans : 用于通过注解指定spring在创建容器时要扫描的包 属性：values:它和basePackages作用一样都是用于在创建容器时要扫描的包，等同于 &lt;context:component-scan base-package=”com.Yogaguo”&gt;&gt; @Bean :用于把当前方法的返回值作为bean对象存入Ioc容器中 属性：name 指定bean的 id ;,默认值为当前方法的名称当我们使用注解时，如果方法有参数，spring会去容器中找有没有可用的bean对象查找的方Autowired一样 @import: 用于导入其他配置类 属性：value :用于指定其他配置类的字节码，当使用Import注解之后，有Import注解的类就是父配置类 @ProperySource: 用于指定properties文件的位置 属性:value,指定文件的名称和路径 关键字：classpath，表示类路径下 代码示例 编写数据库配置JdbcConfig.properties文件，放到resources下 driver=com.mysql.jdbc.Driver JdbcUrl=jdbc:mysql://localhost:3306/day14 Jdbc.name=root password=123456 编写JdbcCongif类 package com.Yogaguo.config; import com.mchange.v2.c3p0.ComboPooledDataSource; import org.apache.commons.dbutils.QueryRunner; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Scope; import javax.sql.DataSource; public class JdbcConfig { @Value( \"${driver}\") private String driver; @Value(\"${JdbcUrl}\") private String JdbcUrl; @Value(\"${Jdbc.name}\") private String username; @Value(\"${password}\") private String password; /** * 创建QueryRunner对象 * @param dataSource * @return */ @Bean(name = \"runner\") @Scope(\"prototype\") public QueryRunner createQueryRunner(DataSource dataSource){ return new QueryRunner(dataSource); } /** * 创建数据源对象 * @return */ @Bean(name = \"dataSource\") public DataSource createDataSourece(){ ComboPooledDataSource ds = new ComboPooledDataSource(); try { ds.setDriverClass(driver); ds.setJdbcUrl(JdbcUrl); ds.setUser(username); ds.setPassword(password); }catch (Exception e){ e.printStackTrace(); } return ds; } 编写主配置类 @Configuration @ComponentScan(basePackages = \"com.Yogaguo\") @Import(JdbcConfig.class) @PropertySource(\"classpath:jdbcConfig.properties\") public class SpringConfiguration { ........ } 6 通过注解获取容器： ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); 整合Junit 在测试类中，每个测试方法都有以下两行代码：ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);IAccountService as = ac.getBean(“accountService”,IAccountService.class);这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。针对上述问题，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建 spring 容器，我们就无须手动创建了，问题也就解决了。我们需要依靠 spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。 1 导入spring 整合Junit的jar 2@RunWith 使用Junit提供的注解把原有的main方法替换了，替换成spring提供的 3 告知spring的运行器，spring的Ioc创建是基于xml还是注解，并且说明位置 @ContextConfiguration: 属性：location :指定xml文件位置，加上classpath关键字，表示类路径 classes:指定注解类所在位置 注意！！！！当使用spring5.0版本时，要求Junit为4.12及以上 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfiguration.class) public class AccountServiceTest { @Autowired private IAccountService accountService; /** * 获取容器 */ /* @Before public void init(){ ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); accountService = (IAccountService)ac.getBean(\"accountService\"); }*/ @Test public void testfindAll() { List&lt;Account> allAccount = accountService.findAllAccount(); for(Account account : allAccount){ System.out.println(account); } } @Test public void testfindAllOne() { Account accouuntById = accountService.findAccouuntById(1); System.out.println(accouuntById); } @Test public void testSave() { Account account = new Account(); account.setPassword(\"111\"); account.setUsername(\"test\"); accountService.saveAccount(account); } 推荐 Spring基础学习01","categories":[{"name":"spring基础学习","slug":"spring基础学习","permalink":"https://Yogaguo.github.io/categories/spring基础学习/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://Yogaguo.github.io/tags/spring/"}]},{"title":"Spring基础学习01","slug":"Demo2020-02-14blog","date":"2020-02-14T05:02:02.000Z","updated":"2020-05-31T08:05:28.021Z","comments":true,"path":"2020/02/14/Demo2020-02-14blog/","link":"","permalink":"https://Yogaguo.github.io/2020/02/14/Demo2020-02-14blog/","excerpt":"Spring概述Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：","text":"Spring概述Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库。 优势 方便解耦，简化开发 通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制,，避免程序耦合。用户也不必再为单 例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用 . AOP 编程的支持 通过 Spring 的 AOP 功能，方便进行面向切面的编程 声明式事务的支持 通过声明式方式灵活的进行事务的管理,提高开发效率和质量 方便集成各种优秀框架 IoC 的概念和作用程序的耦合和解耦 耦合性 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计 应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。 代码示例 public class AccountServiceImpl implements IAccountService { private IAccountDao accountDao = new AccountDaoImpl(); } 业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决。 示例2 早期我们的 JDBC 操作，注册驱动时，我们为什么不使用 DriverManager 的 register 方法，而是采 用 Class.forName 的方式 public class JdbcDemo1 { public static void main(String[] args) { Connection con = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try { Class.forName(\"com.mysql.jdbc.Driver\"); con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/studentmanager\", \"root\", \"123456\"); preparedStatement = con.prepareStatement(\"select * from user\"); resultSet = preparedStatement.executeQuery(); while(resultSet.next()){ System.out.println(resultSet.getString(\"address\")); } } catch (Exception e) { e.printStackTrace(); }finally{ ....................... } 我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如 Oracle），需要 修改源码来重新数据库驱动。这显然不是我们想要的。 当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： Class.forName(\"com.mysql.jdbc.Driver\");//此处只是一个字符串 同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 源码,解决这个问题也很简单，使用配置文件配置。 工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的 方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 控制反转-Inversion Of Control(工厂模式的落地) 由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择，到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map ，所以我们的答案就是 ，在应用加载时，创建一个 Map，用于存放三层对象。我们把这个 map 称之为容器 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变，我们在获取对象时，都是采用 new 的方式。是主动的。我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。这就是所谓的 “ Don`t call us,we will call you “. 简单实现 配置文件(properties): 以key-value形式，注意value为类的全限定类名 accountService=com.item.service.AccountServiceImpl accountDao=com.item.dao.AccountDaoImpl 创建bean工厂：为保证对象的线程安全性，设置容器为单例模式，所以 static 修饰 Map public class BeanFactory { //声明Properties为静态属性， private static Properties pro; //声明容器为静态，单例模式，在JVM加载阶段实例化， private static Map&lt;String,Object> beans; static { try { //创建Properties Object pro = new Properties(); //加载（读取）配置文件到内存 pro.load(BeanFactory.class.getClassLoader().getResourceAsStream(\"properties\")); //创建容器 beans = new HashMap&lt;String, Object>(); //遍历配置文件中的key值，一一枚举出来 Enumeration&lt;Object> keys = pro.keys(); while(keys.hasMoreElements()){ String key = keys.nextElement().toString(); //获取value String beanPath = pro.getProperty(key); //根据value(全限定类型)反射创建对象 Object values = Class.forName(beanPath).newInstance(); //存入Map beans.put(key,values); } } catch (Exception e) { throw new ExceptionInInitializerError(\"初始化错误\"); } } //提供外部获取容器所管理对象的方法 public static Object getBean(String key){ return beans.get(key); } } public static void main(String[] args) { IAccountService as = (IAccountService) BeanFactory.getBean(\"accountService\"); System.out.println(as); as.saveAccount(); }### **使用 spring 的 IOC 解决程序耦合** #### **准备** **spring** **的开发包** - [官网](http://spring.io/) - [下载地址](http://repo.springsource.org/libs-release-local/org/springframework/spring) #### 模拟实践 - 创建业务层和持久层接口与实现 ```java public interface IAccountDao { void saveAccount(); } public class AccountDaoImpl implements IAccountDao { public void saveAccount() { System.out.println(&quot;保存了账户&quot;); } } /** * 业务层的接口 */ public interface IAccountService { /** * 模拟保存账户 */ void saveAccount(); } ** * 账户层实现类 */ public class AccountServiceImpl implements IAccountService { private IAccountDao accountDao = null; public void saveAccount() { accountDao.saveAccount(); } } 第二步：在类的根路径下创建一个任意名称的 xml 文件(不能是中文) 给配置文件导入约束： 约束 spring 管理资源，在配置文件中配置 service 和 dao ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--把对象的创建交给spring管理--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.item.service.AccountServiceImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.item.dao.AccountDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; ``` 测试配置是否成功 public class Client { /** * 获取spring的ioc核心容器，并根据id获取对象 * @param args */ public static void main(String[] args) { /** * 获取核心容器对象 */ ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); /** * 根据id获取Bean对象 */ IAccountService as =(IAccountService) ac.getBean(\"accountService\"); System.out.println(as); as.saveAccount(); } ApplicationContext的三个常用实现类 - ClassPathXmlApplicationContext 可以加载类路径下的配置文件，要求配置文件必须类中加载；否则，加载不了 FileSystemXmlApplicationContext 可以加载磁盘任意路径下的配置文件(必须有访问权限) - AnnotationConfigApplicationContext 用于读取注解，创建容器的，待议 1 BeanFactory 和 ApplicationContext 的区别 BeanFactory 才是 Spring 容器中的顶层接口,ApplicationContext 是它的子接口。 BeanFactory 和 ApplicationContext 的区别： ApplicationContext：单例对象适用: 它在构建核心容器时，创建对象采用的策略是立即加载的方式，也就是说，只要一读取完配置文件，就马上创建配置文件中配置的对象。 BeanFactory: 它在构建核心容器时，创建对象采用的策略是延迟加载的方式，也就是说，什么时候根据id 获取对象了，什么时候才真正创建对象 IOC 中 bean 标签和管理对象细节spring 对bean的管理细节 创建bean的三种方式 第一种方式，使用默认构造方式,在spring的配置文件中，配以id和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，对象无法创建 &lt;bean id=\"accountService\" class=\"com.item.service.AccountServiceImpl\">&lt;/bean>--> 第二种方式，使用普通工厂中的方法创建对象(使用某个类中的方法创建对象，并存入spring容器) public class InstanceFactory { public AccountServiceImpl getAccountService(){ return new AccountServiceImpl(); } } &lt;bean id=\"instanceFactory\" class=\"com.item.Factory.InstanceFactory\">&lt;/bean> &lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\">&lt;/bean>--> 第三种方式，使用即静态工厂中的方法创建对象(使用某个类中的静态方法创建对象，并存入spring容器) package com.item.Factory; import com.item.service.AccountServiceImpl; public class StaticInstanceFactory { public static AccountServiceImpl getAccountService(){ return new AccountServiceImpl(); } } &lt;bean id=\"accountService\" class=\"com.item.Factory.StaticInstanceFactory\" factory-method=\"getAccountService\">&lt;/bean>--> bean 作用域调整 bean标签的scope属性：用于指定bean的作用范围 取值： singleton:单例（默认值） prototype：多例 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境下全局会话范围，当不是集群环境时，它就是session ​ init-method：指定类中的初始化方法名称。 ​ destroy-method：指定类中销毁方法名称。 bean对象的生命周期 单例对象 出生：当容器创建时，对象出生 存活：容器存活，对象一直存活 死亡：容器销毁，对象销毁 多例对象出生：当使用对象时spring框架为我们创建 存活：对象只要是在使用过程中，就一直存活 死亡：当对象长时间不用，且没有对象引用时，GC &lt;bean id=\"accountService\" class=\"com.item.service.AccountServiceImpl\" scope=\"singleton\" init-method=\"init\" destroy-method=\"destory\">&lt;/bean> &lt;/beans> spring的依赖注入依赖注入：Dependency injection:我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。IOC的作用：降低程序间的耦合 依赖关系的管理： 在当前类需要用到其他类的对象，由spring为我们维护，我们只需在配置文件中说明 依赖关系的维护就称之为 依赖注入 依赖注入的数据，有三类 1 基本数据类型和String 2 其他bean类型（在配置文件中注解配置过的bean） 3 复杂类型（）集合 注入的方式，3种 1 构造方法提供 2 set方法 3 注解提供 构造方法注入使用的标签：constructor - arg 标签属性： type ；用于指定要注入的数据类型，该数据类型也是构造方法中某些参数的类型 index:用于指定要注入的数据给构造方法中的指定索引位置的参数赋值，参置从开始 name:用于给构造方法中指定名称的参数赋值 常用！！！！ 以上3个用于指定给构造方法中哪个参数赋值 value:用于提供基本类型和String类型的数据 ref:指定其他bean类型数据，即在spring 的Ioc核心容器中出现的bean对象 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建 弊端：改变了bean对象的实例化方式，使我们在创建对象时，即使用不到这些数据，也必须提供！ public class AccountServiceImpl implements IAccountService { private String str; private Integer age; private Date time; public AccountServiceImpl(String str, Integer age, Date time) { this.str = str; this.age = age; this.time = time; } public void saveAccount() { System.out.println(\"service中的saveAccount执行了。。。\"+str+\",\"+age+\",\"+time); } } &lt;bean id=\"accountService\" class=\"com.item.service.AccountServiceImpl\" > &lt;constructor-arg name=\"str\" value=\"test\" >&lt;/constructor-arg> &lt;constructor-arg name=\"age\" value=\"18\" >&lt;/constructor-arg> &lt;constructor-arg name=\"time\" ref=\"now\" >&lt;/constructor-arg> &lt;/bean> &lt;bean id=\"now\" class=\"java.util.Date\">&lt;/bean> 测试 public static void main(String[] args) { /** * 获取核心容器对象 */ ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); /** * 根据id获取Bean对象 */ IAccountService as =(IAccountService) ac.getBean(\"accountService\"); as.saveAccount(); 结果： service中的saveAccount执行了。。。test,18,Fri Feb 14 15:06:18 CST 2020 set方法注入 常用！！！ 涉及的标签：property 属性： name:注入时所调用的set方法名称 value:用于提供基本类型和String类型的数据 ref:指定其他bean类型数据，即在spring 的Ioc核心容器中出现的bean对象 ​ 优势：创建对象时没有明确的限制，可以直接使用默认构造方法​ 弊端：如果有某个成员必须有值。获取对象时set方法有可能没有指向 public class AccountServiceImpl2 implements IAccountService { private String str; private Integer age; private Date time; public void setStr(String str) { this.str = str; } public void setAge(Integer age) { this.age = age; } public void setTime(Date time) { this.time = time; } public void saveAccount() { System.out.println(\"service中的saveAccount执行了。。。\"+str+\",\"+age+\",\"+time); } } &lt;bean id=\"accountService2\" class=\"com.item.service.AccountServiceImpl2\" > &lt;property name=\"str\" value=\"Yogaguo\" >&lt;/property> &lt;property name=\"age\" value=\"18\">&lt;/property> &lt;property name=\"time\" ref=\"now\">&lt;/property> &lt;/bean> 复杂类型的注入(集合类型的注入) 用于给List结构集合类型的注入的标签 list array set 用于给Map结构集合类型的注入的标签 map props 结构相似，标签可以互换 package com.item.service; import java.util.*; /** * 账户层实现类 */ public class AccountServiceImpl3 implements IAccountService { private String[] strings; private List&lt;String> list; private Map&lt;String,String> map; private Properties properties; public void setStrings(String[] strings) { this.strings = strings; } public void setList(List&lt;String> list) { this.list = list; } public void setMap(Map&lt;String, String> map) { this.map = map; } public void setProperties(Properties properties) { this.properties = properties; } public void saveAccount() { System.out.println(Arrays.toString(strings)); System.out.println(list); System.out.println(map); System.out.println(properties); } } &lt;bean id=\"accountService3\" class=\"com.item.service.AccountServiceImpl3\"> &lt;property name=\"strings\"> &lt;array> &lt;value>aaa&lt;/value> &lt;value>bbb&lt;/value> &lt;value>ccc&lt;/value> &lt;/array> &lt;/property> &lt;/bean>","categories":[{"name":"spring基础学习","slug":"spring基础学习","permalink":"https://Yogaguo.github.io/categories/spring基础学习/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://Yogaguo.github.io/tags/spring/"}]},{"title":"SQL语句是如何执行的?","slug":"demo2020-02-11","date":"2020-02-11T10:38:40.000Z","updated":"2020-05-31T08:05:28.107Z","comments":true,"path":"2020/02/11/demo2020-02-11/","link":"","permalink":"https://Yogaguo.github.io/2020/02/11/demo2020-02-11/","excerpt":"MySQL逻辑架构 首先头脑中构建一副MySQL个组件是如何协同工作,MySQL最与众不同的地方在于它的存储引擎架构，这种架构的设计将查询处理(Query Processing)及其他系统任务(Server Task)和数据的存储 / 提取分离。更加高效。下面是MySQL的基本架构示意图，从这里可以看出SQL语句在各个组件间的执行过程 最上层并不是MySQL独有的，大多数基于网络的客户端 / 服务器的工具或者服务都有相似的架构，比如连接处理 授权认证。。。。","text":"MySQL逻辑架构 首先头脑中构建一副MySQL个组件是如何协同工作,MySQL最与众不同的地方在于它的存储引擎架构，这种架构的设计将查询处理(Query Processing)及其他系统任务(Server Task)和数据的存储 / 提取分离。更加高效。下面是MySQL的基本架构示意图，从这里可以看出SQL语句在各个组件间的执行过程 最上层并不是MySQL独有的，大多数基于网络的客户端 / 服务器的工具或者服务都有相似的架构，比如连接处理 授权认证。。。。 第二次是MySQL的核心服务功能区(Server),包括连接器，查询缓存 分析器 优化器 ，执行器等待核心服务功能，以及所有的内置函数（日期，时间 数学加密),还有所有跨存储引擎的功能都在这一次实现，比如存储过程，触发器，视图等，还有一个通用的日志模块 binglog日志模块。 第三次包含了存储引擎。存储引擎负责数据的存储和提取。架构是插件式的。支持InnoDB,MyISAM,Memory多个存储引擎,其中InnoDB引擎有日志模块redolog 模块。 当执行建表的时候，如果不指定引擎类型，默认使用的就是InnoDB,当然，也可以通过指定引擎的类型选择，在 create table语句中用engine=memory来指定。 如图所示，不同的存储引擎公用一个Server层 select * from student where id=10; 连接器第一步会先里连接数据库，连接器会负责和客户端建立连接，获取权限，维持和管理连接。如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说在成功连接后，即使用管理员账号对这个用户权限做了修改，也不会影响已经存在的连接的权限，该用户不受影响的。在连接完成后，如果用户没有后序动作，这个连接就处于空闲态，如果长时间客户端没动静，连接器会自动断开，这时间由参数wait_timeout决定，默认8h. 在连接断开后，下一次需要重连，在数据库中有长连接，短连接，前者指连接成功后，客户端持续有请求，则一直使用此连接，后者指每次执行很少的查询后就断开连接。下次再次连接。建立连接是比较耗时的，所以尽量减少建立连接动作，尽量使用长连接，但是全部使用长连接，MySQL内存涨的很快，因为MySQL执行中临时使用的内存是管理在连接对象里，它们只能在连接断开时被释放，所以长期连接积累下来，内存越来越大，最后OOM，MySQL就会异常Restart。建议使用一段时间后执行 mysql_reset_connection初始化连接资源。会直接恢复到刚刚创建的状态。 查询缓存连接建立后，执行查询语句的时候，会先查询缓存，Mysql会先校验这个sql是否执行过，以Key-Value的形式缓存在内存中，Key是查询语句，Value是查询的结果。如果缓存key被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件. 大多数情况下不建议使用查询缓存，因为往往弊大于利。 查询缓存实现非常频繁，对一个表的更新，这个表所有的查询缓存都会被清空。Mysql 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以直接删掉了。 分析器MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析SQL语句是做什么的，分析器也会分为几步： 词法分析 ：分析器会识别SQL语句中的字符串分析是什么，代表什么。从你输入的”select”关键字识别出来，是一条查询语句，把字符串 “ student “ 识别为 “ 表名student “,字符串 “ id “ 识别为 “ 列id “. 语法分析：判断你输入的SQL是否正确，是否符合MySQL的语法。如果语句不对，就会出现熟悉的提示信息：”You have an error in your SQL syntax” 完成这2步之后，mysql就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器。 优化器 优化器就是在表中有多个索引时，决定使用哪个索引，多表关联时，决定表间连接顺序，优化器根据自己的优化算法进行选择执行效率最好的一个方案。 执行器 在经过分析器知道要做什么，优化器知道该如何做后，进入执行器阶段。先判断此表有无查询权限，如果没有，返回错误信息。如果有权限，就打开表执行，执行器依据引擎定义，使用指定引擎interface，调用InnoDB引擎interface取表第一行，判断 id == 10 ,不是，跳到下一行，重复判断，找到后存入结果集中。 总结 Mysql 主要分为Server层和引擎层，Server层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用。 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory等。 查询语句的执行流程如下：权限校验（如果命中缓存）—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎 参考 《mysql专栏45讲》 《高性能mysql第三版》","categories":[{"name":"mysql","slug":"mysql","permalink":"https://Yogaguo.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://Yogaguo.github.io/tags/mysql/"}]},{"title":"Morris遍历实现二叉树的三种遍历","slug":"2019-11-19","date":"2019-11-19T13:23:38.000Z","updated":"2020-05-31T12:09:59.826Z","comments":true,"path":"2019/11/19/2019-11-19/","link":"","permalink":"https://Yogaguo.github.io/2019/11/19/2019-11-19/","excerpt":"","text":"引入首先看一个题：给定一颗二叉树头结点，完成二叉树的先序 后序 中序 ，如果二叉树的结点数为 N ，要求时间复杂度为O(N),额外空间复杂度为O(1). 首先看普通的递归，其实质是使用了系统提供的函数栈；非递归的方法使用了申请的栈，两者的额外空间复杂度都与树事务高度有关，所以空间复杂度为O(h)。 本题要求空间复杂度为O(1),这就要求使用 Morris 遍历 Morris遍历Morris遍历的实质就是避免使用栈结构，而是让下层到上层有指针，通过让底层结点指向 null 的空闲指针指向上层某个结点，从而完成下层到上层的移动。因为二叉树的很多结点都有大量空闲指针，比如，某些结点没有右孩子，那么这个结点的 right 指针就指向 null ,Morris遍历正是用了这些空闲指针。 具体流程： 当前结点为 cur1,cur1无左子树，cur1向右移动，cur1 = cur1.right cur1有左子树，找左子树最右结点（mostright） - mostright的右孩子为 null ,右孩子指向 cur1, cur1 向左移动 - mostright的右孩子为 cur,mostright的右孩子指向 null ,cur向右 cur1 = cur1.right. 总结为：在树中，对于任何一个有左子树的结点，会 2 次回到自己；没有左子树的结点，只会 1 次回到自己，整体顺序为：先回到当前结点，遍历完自己的左子树之后，再回到 cur,在遍历右子树 public static void morris(Node head) { if( head == null) { return; } Node cur1 = head; Node cur2 = null; while(cur1 != null) { cur2 = cur1.left ; if(cur2 != null) { while(cur2.right != null &amp;&amp; cur2.right != cur1) { cur2 = cur2.right; } if(cur2.right == null) { cur2.right = cur1; cur1 = cur1.left; continue; }else { cur2.right = null; } } cur2 = cur2.right; } } Morris实现先序遍历在Morris的基础上，只要第一次回到当前结点，即 当前结点左子树最右结点的右孩子为 null ;或者当前结点没有左子树 就直接打印，从而实现先序遍历 public static void morrisPre(Node head) { if( head == null) { return; } Node cur1 = head; Node cur2 = null; while(cur1 != null) { cur2 = cur1.left ; if(cur2 != null) { while(cur2.right != null &amp;&amp; cur2.right != cur1) { cur2 = cur2.right; } if(cur2.right == null) { cur2.right = cur1; System.out.print(cur1.value+\" \"); cur1 = cur1.left; continue; }else { cur2.right = null; } }else { System.out.print(cur1.value+\" \"); } cur1 = cur1.right; } } Morris实现中序遍历因为中序遍历是：左中右，那么在当前结点没有左子树时，就直接打印；在当前结点有左子树的情况下，第二次回到自己时，打印，实现中序遍历。 我们知道，不管是没有左子树时，还是第二次回到自己时，下一步都是向右移动，所以，在代码中可以在当前结点 cur1 向右移动时打印结点 public static void morrisIn(Node head) { if( head == null) { return; } Node cur1 = head; Node cur2 = null; while(cur1 != null) { cur2 = cur1.left; if( cur2 != null) { while(cur2.right != null &amp;&amp; cur2.right != cur1) { cur2 = cur2.right; } if(cur2.right == null) { cur2.right = cur1; cur1 = cur1.left; continue; }else { cur2.right = null; } } System.out.print(cur1.value+\" \"); cur1 = cur1.right; } } Morris实现后序遍历后序遍历有点复杂，在第 2 次回到当前结点时，把左子树右边界逆序打印完后，当整个循环走完，对于整个树，在单独打印树的右遍历。 对于逆序，可以借助栈，不过会有额外空间额代价，这里采用 链表逆序法 reverse(head), public static void morrisPos(Node head) { if(head == null) { return; } Node cur1 = head; Node cur2 = null; while(cur1 != null) { cur2 = cur1.left; if(cur2 != null) { while(cur2.right != null &amp;&amp; cur2.right != cur1) { cur2 = cur2.right; } if(cur2.right == null) { cur2.right = cur1; cur1 = cur1.left; continue; }else { cur2.right = null; printEdge(cur1.left); } } cur1 = cur1.right; } printEdge(head); } private static void printEdge(Node left) { Node cur = reverse(left); while(cur != null) { System.out.print(cur.value+\" \"); cur = cur.right; } } private static Node reverse(Node cur) { Node next = null; Node pre = null; while(cur != null) { next = cur.right; cur.right = pre; pre = cur; cur = next; } return pre; }","categories":[{"name":"算法","slug":"算法","permalink":"https://Yogaguo.github.io/categories/算法/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://Yogaguo.github.io/tags/二叉树/"}]},{"title":"从JVM层理解Java方法调用","slug":"2019-11-8","date":"2019-11-08T11:22:32.000Z","updated":"2020-05-31T12:10:13.833Z","comments":true,"path":"2019/11/08/2019-11-8/","link":"","permalink":"https://Yogaguo.github.io/2019/11/08/2019-11-8/","excerpt":"","text":"解析首先，方法调用不等同于方法执行，方法调用阶段唯一的任务就是确定调用方法的版本，不涉及方法内部的运行过程。 在Java的世界中，一切的方法调用在 Class 文件里存储的都只是符号引用， 而不是在实际运行时的内存布局的入口地址（相当于直接引用）。 在类加载阶段，会将其中一部分的符号引用解析为直接引用，而这种解析成立的前提是：调用目标在程序代码写好 编译期进行编译时必须确定下来。我们打这种方法的调用称为 解析。满足这种要求（编译期可知，运行期不可知）的方法包括：静态方法（与类型有关，在初始化阶段就已确定） 私有方法（外部类不可访问），它们的性质就决定了不可能通过继承什么的重写。 在JVM中，只要能被invokestatic和invokespecial指令调用的方法，都满足上述（在解析阶段唯一确定），符合条件的方法：静态方法 私有方法 实例构造器 父类方法。它们 在类加载阶段，会将符号引用解析为该方法的直接引用。 静态分配package cn.bjtxt.text; public class StaticDisPatch { static abstract class Human{ } static class Man extends Human{ } static class Women extends Human{ } public void sayHello(Human guy) { System.out.println(\"hello guy\"); } public void sayHello(Man guy) { System.out.println(\"hello man\"); } public void sayHello(Women guy) { System.out.println(\"hello women\"); } public static void main(String[] args) { Human man = new Man(); Human women = new Women(); StaticDisPatch sr = new StaticDisPatch(); sr.sayHello(man); sr.sayHello(women); } } 运行结果： hello guy hello guy 在上述代码中，把 “Human” 称为 静态类型，后面的 “Man” 称为实际类型，静态类型的变化只在使用时发生，变量本身不发生改变，最终的静态类型是在编译期确定的；而实际类型的变化结果在运行期才可知。编译期在编译程序时并不知道一个对象的实际类型。 在上述代码中，两次调用 sayHello（）方法，使用哪个重载版本，就完全取决与传入的参数的类型 数量（签名），JVM（或者说编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。静态类型在编译期就可以确定。 总结：在编译期间，Javac编译期会根据参数的静态类型决定使用哪个版本，所有依赖静态类型来定位方法的执行版本的分派动作称为静态分派，典型的就是重载。 动态分派—多态与重写package cn.bjtxt.text; public class DynamicDisPatch { static abstract class Human{ protected abstract void sayHello(); } static class Man extends Human{ @Override protected void sayHello() { System.out.println(\"man say Hello\"); } } static class Women extends Human{ @Override protected void sayHello() { System.out.println(\"women say Hello\"); } } public static void main(String[] args) { Human man = new Man(); Human women = new Women(); man.sayHello(); women.sayHello(); man = new Women(); man.sayHello(); } } 运行结果： man say Hello women say Hello women say Hello 显然，这里不能用静态类型解释，其实造成此结果的愿意：这两个变量的实际类型不同。如果进行反编译，会发现两条 invokespecial 指令，但是两条指令的最终执行目标却不一样，这就要从 invokespecial 指令的运行时的查找过程说起： 首先： 找到操作数栈顶的第一个元素所指向的对象的实际类型，标记为 A 在 类型 A 中找与常量池中的描述符和简单名称相符的方法，找到进行权限访问，通过则返回此方法的直接引用，不通过，抛异常 IIegalAccessError 找不到，按继承关系从下往上找。 由于 invokespecial 指令执行的第一步就是在运行期间确定接受者的实际类型，所以两次调用中的 invokespecial 指令都是把常量池的类方法符号引用解析到不同的直接引用上，这就是 重写的本质。 单分配与多分配package cn.bjtxt.text; public class DisPatch { static class QQ{ } static class Weixin{ } public static class Father{ public void choose(QQ qq) { System.out.println(\"father choose qq\"); } public void choose(Weixin wechat) { System.out.println(\"father choose wechat\"); } } public static class Son extends Father{ @Override public void choose(QQ qq) { // TODO Auto-generated method stub System.out.println(\"son choose qq\"); } @Override public void choose(Weixin wechat) { // TODO Auto-generated method stub System.out.println(\"son choose wechat\"); } } public static void main(String[] args) { Father father = new Father(); Father son = new Son(); father.choose(new Weixin()); son.choose(new QQ()); } } 运行结果： father choose wechat son choose qq 分析： ​ 在编译阶段，由静态分配可知：产生的两条 invokespecial 指令的参数分别为常量池中的 Father.choose(weichat)和Father.choose(qq)方法的符号引用。 ​ 在运行时，也就是动态分配时，在执行son.choose(new QQ()),所对应的 invokespecial 指令时，编译期已经确定了目标方法的签名必须为 choose(QQ),JVM此时不关心传递过来的参数的类型，唯一可以影响JVM的因素就是：此方法接受的实际类型是Father还是Son 方法表由于动态分配是非常频繁的动作，基于JVM性能的考虑，常用的“优化手段”——在方法区建立一个虚方法表，表中存放着各个方法的实际入口地址。如果某个方法在子类中没有重写，那么子类的虚方法表的地址入口和父类相同方法的入口地址是一致的。都指向父类的实现入口，如果重写了，子类方法表中的地址将会指向子类实现版本的入口。 为了程序实现上的方便，具有相同签名的方法，在父类，子类的虚方法表中都应当具有一样的索引，这样当类型变化时，只需要变更查找的方法表。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://Yogaguo.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://Yogaguo.github.io/tags/Java/"}]},{"title":"一致性哈希算法的原理","slug":"2019-11-03","date":"2019-11-03T10:42:54.000Z","updated":"2020-05-31T12:10:27.388Z","comments":true,"path":"2019/11/03/2019-11-03/","link":"","permalink":"https://Yogaguo.github.io/2019/11/03/2019-11-03/","excerpt":"","text":"一种常见的场景： 工程师经常使用服务器集群来设计和实现数据缓存，经典的策略是： 无论是添加，查询还是删除数据，都先将数据的 id 号通过哈希函数转换为一个哈希值，记为 key. 如果现在机器有 N 台，则计算 key%N 的值，这个值就是该数据所属的机器编号，无论是添加 删除 还是查询，都只是在这台机器上进行 请注意，这种缓存策略可能带来一个问题： 如果现在是双十一，我要加机器来满足负载，或者是有时候要去掉几台机器，N变化了，所有的数据都不得不根据 id 重新计算一遍哈希值，并将哈希值对新的机器取模，然后就是大规模的数据迁移。这个代价很高！ 为了解决这个问题，引入一致性哈希算法，这是一种很好的数据缓存设计方案。 假设所有的数据的 id 通过哈希函数转换成的哈希范围是 2^23,范围在 0 ~（2^23）-1 的数字空间中。现在我们可以将这些数字头尾相连。想象成一个闭合的环形，那么一个数据在计算出哈希值之后就会认为对应到环中的一个位置。 接下来，想象有三台机器通过自己的 ip 计算出来后也在这样的一个环中的各自位置上，那么一条数据如何确定归属那台机器？ 首先把数据的 id 用哈希函数计算出哈希值，并映射到环上相应位置。 然后顺时针寻找离自己位置最近的机器，这台机器就是该数据的归属。 在图 6-4中，data1根据其 id 计算出的哈希值为 key1 ,顺时针的第一台机器是 machine2,所以data1归属；同理，data2归属 machine3,data3和data4归属 machine1. 增加机器时的处理：假设有两台机器（m1 m2）和三个数据（data1 data2 data3）,数据和机器在环上的结构图 6-5 如果此时想加入新的机器 m3 ,同时算出机器 m3 的 id 在 m1和 m2 右半边的环上，那么发生 的变化如图 6-6 在没有添加 m3 之前，从 m1 到现在 m3 位置上的这一段是 m2 掌管的一部分；添加 m3 之后统一归属 m3 ,同时要把这一段的数据从 m2 迁移到 m3 上。由此可见，添加机器时的调整是比较小的。在删除机器时也一样。只要把要删除机器中的机器全部迁移到顺时针找到的机器中。 机器负载不均的处理 根据哈希性质，它的离散型是随着输入域量的增加变好的，实现几乎均匀分布。如果机器较少，有可能造成机器在整个环上的分布不均匀，从而导致机器之间的负载不均衡。比如。图6-7 所示的两台机器，m1可能比m2 面临更大的负载。 为了解决这种问题，一致性哈希算法引入了虚拟节点机制,即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。 具体做法可以在机器 ip 或 hostname 的后面增加编号或端口号来实现。以图6-7的看，可以为每台机器计算两个节点，分别为m1-1 ,m1-2和m2-1 m2-2的哈希值，于是就形成了四个虚拟节点，这样节点数就变多了，根据哈希函数的性质，平衡性自然会变好。 当某一条数据计算出归属于m1-2时，再根据表的跳转，数据将最终归属于实际的m1机器。","categories":[{"name":"算法","slug":"算法","permalink":"https://Yogaguo.github.io/categories/算法/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://Yogaguo.github.io/tags/哈希/"}]},{"title":"< Java并发编程的艺术>读后总结 一Java内存模型与happens-before","slug":"2019-10-29","date":"2019-10-29T08:33:24.000Z","updated":"2020-05-31T12:10:43.377Z","comments":true,"path":"2019/10/29/2019-10-29/","link":"","permalink":"https://Yogaguo.github.io/2019/10/29/2019-10-29/","excerpt":"","text":"Java内存模型概述 Java虚拟机规范试图定义一种Java内存模型(JMM)，来屏蔽各种硬件和OS的内存访问差异，让Java程在各种平台达到一致的访问效果。其实就是CPU的执行速度与内存访问的速度差异相差巨大，所以在CPU里加了几层高速缓存，有点像计算机组成原理中的Cache。 ​ 在Java内存模型中，JMM抽象出：所有变量都是存在于主存中，类似于普通内存，每个线程又包含自己的本地工作内存区，就类似于CPU的Cache，所以线程的操作都是以自己的本地工作内存为主，它们就只能访问自己的工作内存，线程写完成完成后要把值刷新会主存中。 在线程执行时，首先从主存中的read值，在load到工作内存中，交给CPU处理，执行完毕，再给工作内存中的变量重写赋值，最后刷新回主存。 指令重排在执行程序时，为了提高性能，编译期和处理器常常会对指令进行重排序。 数据依懒性如果两个操作操作访问同一个变量，且这两个操作中有一个 写操作，此时这两个操作就存在数据依懒性。 只要重排这两个操作的执行顺序，执行结果就会被改变！所以编译期和处理器不会改变存在数据依懒性的两个操作的执行顺序。 as-if-serial(有序性)不管如何重排序，单线程的程序执行结果不会被改变。编译期和处理器必须遵守 as-if-serial语义。所以编译期和处理器不会对存在数据依懒性的操作重排序。 as-if-serial语义把单线程程序 “保护起来”， happens-before(有序性)happens-before 要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。并不要求前一个操作必须要在后一个之前执行 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁 volatile:对一个volatile域的写，happens-before 于后续任意对这个 volatile 域的读 传递性：A happens-before B B happens-before C ——》A happens-before C start() 规定：线程 A 执行操作 ThreadB.start(启动线程B)，则线程 A 的 ThreadB.start 操作 happens-before 于线程B的任意操作 比如：线程A在执行ThreadB.start()之前修改了一些共享变量，线程B在开始执行时会读到修改的变量 join()规则：线程A执行操作Thread.join()并成功返回，则线程B中任意操作 happens-before于线程A从Thread.join()操作成功返回。 重排序对多线程的影响在单线程中，存在 as-if-serial，所以不会不会改变执行结果。但在多线程中，重排序会对执行结果修改。 当程序未正确同步时，就可能存在数据竞争（在一个线程读，在一个线程写，写与读未同步），当存在数据竞争时，运行结果往往不一样。如果一个多线程正确同步。就没有数据竞争。JMM对正确同步的多线程程序内存一致性做了保证：即顺序一致性（程序的执行结果与在顺序一致性内心模型中的执行结果相同）。 而未同步的程序在JMM中执行时，整体上无序，执行结果也未知 public class T9 { boolean runing=true; //加上volatile，线程就会结束。否则一直死循环 void m() { System.out.println(\"m start\"); while(runing) { } System.out.println(\"m end\"); } public static void main(String[] args) { T9 t=new T9(); new Thread(()->t.m()).start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } t.runing=false; } } 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程过程中直接使用这个copy，并不会每次都去 读取堆内存，这样，当主线程修改running的值后，t1线程感知不到，所以不会停止运行","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://Yogaguo.github.io/categories/Java并发编程/"}],"tags":[{"name":"Java内存模型","slug":"Java内存模型","permalink":"https://Yogaguo.github.io/tags/Java内存模型/"}]},{"title":"Java设计模式之工厂模式","slug":"2019-10-28","date":"2019-10-28T08:48:24.000Z","updated":"2020-05-31T08:05:27.704Z","comments":true,"path":"2019/10/28/2019-10-28/","link":"","permalink":"https://Yogaguo.github.io/2019/10/28/2019-10-28/","excerpt":"Java设计模式之工厂模式（简单工厂模式 工厂方法模式） 在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例,new操作符就是用来构造对象实例的。但是在一些情况下, new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况,新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。","text":"Java设计模式之工厂模式（简单工厂模式 工厂方法模式） 在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例,new操作符就是用来构造对象实例的。但是在一些情况下, new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况,新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。 模式的问题：你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？ 解决的方案：建立一个工厂来创建对象。 分类工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。工厂模式可以分为三类： 1）简单工厂模式（Simple Factory）2）工厂方法模式（Factory Method）3）抽象工厂模式（Abstract Factory） 简单工厂模式 客户想自己创建交通工具来使用客户需要知道怎么去创建一个交通,客户和交通工具就紧密耦合在一起了.为了降低耦合,就出现了工厂类,把创建工具的操作细节都放到了工厂里面去,客户直接使用工厂的创建工厂方法,传入想要的交通工具类型就行了,而不必去知道创建的细节.这就是工业革命了：简单工厂模式 /** * 产品类 */ public interface TrafficTools { void go(); } public class Car implements TrafficTools { @Override public void go() { System.out.println(\"Car Go!\"); } } public class Plane implements TrafficTools { @Override public void go() { System.out.println(\"Plane flying!\"); } } ** * 简单工厂：交通工具的工厂,简单工厂的可扩展性不好-》针对每一交通工具做个工厂 * @author LENOVO * */ public class SimpleFactory { public Car creatCar() { //在之前可以加入其它操作:权限。。。 return new Car(); } public Plane creatPlane() { //在之前可以加入其它操作:权限。。。 return new Plane(); } } /** * 客户： * 简单工厂：站在一个一个产品的维度看：定义创建实体产品的工厂，方便产品的扩展 */ public class Main { public static void main(String[] args) { TrafficTools f = new SimpleFactory().creatCar(); TrafficTools f3 = new SimpleFactory().creatPlane(); } } 简单工厂模式又称静态工厂方法模式。重命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。 先来看看它的组成： 1) 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品 2) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。 3) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 但是每增加一种交通工具，都要在工厂类中增加相应的创建业务逻辑，这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。 工厂方法模式工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。工厂方法模式组成： 1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有 的代码。可以看出工厂角色的结构也是符合开闭原则的 /** * 产品类 */ public interface TrafficTools { void go(); } public class Car implements TrafficTools { @Override public void go() { System.out.println(\"Car Go!\"); } } public class Plane implements TrafficTools { @Override public void go() { System.out.println(\"Plane flying!\"); } } ** * 工厂类 */ public class CarFactory { public Car create() { System.out.println(\"create car!\"); //之前做些日志工作，或者其他事情，最后在 new 出来 return new Car(); } } public class PlaneFactory { public Plane create() { System.out.println(\"create plane!\"); //之前做些日志工作，或者其他事情，最后在 new 出来 return new Plane(); } } public class Main { public static void main(String[] args) TrafficTools f = new CarFactory().create(); } } 抽象工厂模式随着客户的要求越来越高，每种交通工具需要不同配置的小型武器和司机的食餐等一系类懂东西。于是这个工厂开始生产小型武器和配备不同的食物，用来满足司机或者顾客的需求。这时候工厂有两个系列的产品:武器和司机食物。 形成了产品族 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象.比如，Car 司机使用AK47,吃面包 Subway司机用AK46,吃蘑菇，那么使用抽象工厂，就无需为每种交通工具配置相应的东西，他会自动根据交通工具生产相应的配物 /** * 创建工厂的抽象类 */ public abstract class AbstractFactory { //制造食物 abstract Food creatFood(); //制造武器 abstract Weapon creatWeapon(); //制造交通工具 abstract Vehicle creatVehicle(); } /** * 产品类 / //交通工具及其种类 public abstract class Vehicle { abstract void go(); } public class Car extends Vehicle{ @Override public void go() { System.out.println(\"Car Go!\"); } } public class Subway extends Vehicle { @Override public void go(){ System.out.println(\"subway go\"); } } //食物及其种类 public abstract class Food { abstract void printName(); } public class Bread extends Food{ @Override public void printName(){ System.out.println(\"面包1\"); } } public class Mushroom extends Food { @Override public void printName(){ System.out.println(\"小蘑菇\"); } } //武器及其种类 public abstract class Weapon { abstract void shoot(); } public class AK46 extends Weapon { @Override public void shoot(){ System.out.println(\"射击2\"); } } public class AK47 extends Weapon{ @Override public void shoot(){ System.out.println(\"射击\"); } } /** * 产品簇:1 Car AK47 Bread * 2 Subway AK46 Mushroom * 在这里探讨一个问题： * 注意在设计中:形容词的类用 interface;名词用 Abstract * 抽象工厂方便于 产品簇的扩展，但是产品本身不好扩展 * 工厂方法方便于产品本身的扩展性好。 * 两种模式维度不同 */ @SuppressWarnings(\"all\") public class Main { public static void main(String[] args) { /** * 好处在于，你想换成subway，只需改：new CarFactory() ——》new SubwayFactory(); */ AbstractFactory abstractFactory = new CarFactory(); Vehicle c = abstractFactory.creatVehicle(); c.go(); Food b = abstractFactory.creatFood(); b.printName(); Weapon w = abstractFactory.creatWeapon(); w.shoot(); ​","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://Yogaguo.github.io/categories/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://Yogaguo.github.io/tags/工厂模式/"}]},{"title":"Redis初识","slug":"2019-10-23","date":"2019-10-22T09:48:40.000Z","updated":"2020-05-31T08:05:27.641Z","comments":true,"path":"2019/10/22/2019-10-23/","link":"","permalink":"https://Yogaguo.github.io/2019/10/22/2019-10-23/","excerpt":"Redis 概念：redis是一款高性能的NOSQL系列的非关系型数据库,redis内部是一个key-value存储系统。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型，类似于Java中的map）。Redis基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器.","text":"Redis 概念：redis是一款高性能的NOSQL系列的非关系型数据库,redis内部是一个key-value存储系统。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型，类似于Java中的map）。Redis基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器. 为什么用 Redis互联网时代背景下: 当数据量的总大小一个机器放不下时。 数据索引一个机器的内存放不下时。 访问量（读写混合）一个实例放不下时 单机时代： 如果每次存储成千上万条数据，这样很会导致mysql的性能很差，存储以及读取速度很慢，然后就演变成缓存+mysql+垂直拆分的方式 Cache作为中间缓存将所有的数据先保存到缓存中，然后再存入mysql中，减小数据库压力，提高效率。但是当数据再次增加到又一个量级，上面的方式也不能满足需求，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。 主从分离模式在redis的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。 Redis的优势 易扩展 大数据量提高性能 多样灵活的数据格式 Redia的安装与介绍 官网：https://redis.io 中文网：http://www.redis.net.cn/ 介绍： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端Redis的数据结构redis存储的是：key,value 格式的数据，其中 key 都是键值对；value 有5种不同的数据结构 value 的5种数据结构： 字符串类型 String 哈希类型 hash map的格式 列表类型 list linkedlist格式 集合类型 有序集合类型 基本命令 字符串操作 存储：set key value 获取：get key 删除：del key 哈希类型 存储：hset key field value 获取： ​ hget key field:获取指定的field对应的值 ​ hgetall key 获取所有的field和value 删除：hdel key field 列表类型：可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加：lpush key value将元素加入列表左边； ​ rpush key value将元素加入列表右边 ​ 获取：lrange key start end:范围获取 ​ 删除：lpop key: 删除列表左边的元素并将元素返回；rpop key 集合类型：不允许重复元素，元素无序 存储：sadd key value 获取：smembers key:获取 set 集合中所有的元素 删除：srem key value:删除集合中的某个元素 有序集合：sortedset 不允许重复元素，元素有序,.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 获取：zrange key start end 1. 存储：zadd key score value 127.0.0.1:6379> zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379> zadd mysort 50 lisi (integer) 1 127.0.0.1:6379> zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379> zrange mysort 0 -1 1) \"lisi\" 2) \"zhangsan\" 3) \"wangwu\" 127.0.0.1:6379> zrange mysort 0 -1 withscores 1) \"zhangsan\" 2) \"60\" 3) \"wangwu\" 4) \"80\" 5) \"lisi\" 6) \"500\" 3. 删除：zrem key value 127.0.0.1:6379> zrem mysort lisi (integer) 1 通用命令 keys *查询所有的键 type key键值类型 del key删除指定的键值对Redis的持久化 redis 是一个内存数据库，当Redis 服务器重启，或者电脑重启，数据多会丢失，可以将 redis 内存中的数据持久化到硬盘的文件中。 Redis 持久化的机制 RDB:默认方式，在一定的间隔时间中，检测 key 的变化情况，然后持久化。 1.具体操作：编辑 redis.windows.conf文件 after 900 sec (15 min) if at least 1 key changed # after 300 sec (5 min) if at least 10 keys changed # after 60 sec if at least 10000 keys changed ```xm save 900 1 save 300 10 save 60 10000 ``` - 重新启动redis服务器，并指定配置文件名称 D:\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf ADF:日志记录的方式，可以记录每一条命令的操作，在每一条命令后，持久化数据（不推荐） Java 客户端 Jedis Jedis :一款java操作redis数据库的工具. 下载jedis的jar包 使用 获取连接Jedis jedis = new Jedis(&quot;localhost&quot;,6379); 操作jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); 关闭连接jedis.close() 2 .Jedis操作各种redis中的数据结构 1.字符串类型 string //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 //存储 jedis.set(\"username\",\"zhangsan\"); //获取 String username = jedis.get(\"username\"); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(\"activecode\",20,\"hehe\");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 哈希类型 hash ： map格式 hset hgethgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // 存储hash jedis.hset(\"user\",\"name\",\"lisi\"); jedis.hset(\"user\",\"age\",\"23\"); jedis.hset(\"user\",\"gender\",\"female\"); // 获取hash String name = jedis.hget(\"user\", \"name\"); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); ```Jdeis连接池 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接 ```java连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } } ```","categories":[{"name":"Redis","slug":"Redis","permalink":"https://Yogaguo.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://Yogaguo.github.io/tags/Redis/"}]},{"title":"Ajax与JSON","slug":"2019-10-22","date":"2019-10-22T07:20:51.000Z","updated":"2020-05-31T12:11:26.886Z","comments":true,"path":"2019/10/22/2019-10-22/","link":"","permalink":"https://Yogaguo.github.io/2019/10/22/2019-10-22/","excerpt":"","text":"概念： ASynchronous JavaScript And XML 异步的JavaScript 和 XML 异步和同步：客户端和服务器端相互通信的基础上 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。提升用户的体验 ​ 实现方式 原生的JS实现方式 1.创建核心对象 ​ var xmlhttp; ​ if (window.XMLHttpRequest) ​ {// code for IE7+, Firefox, Chrome, Opera, Safari ​ xmlhttp=new XMLHttpRequest(); ​ } ​ else ​ {// code for IE6, IE5 ​ xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); ​ } ​ ​ 2. 建立连接 ​ /* ​ 参数： ​ 1. 请求方式：GET、POST ​ * get方式，请求参数在URL后边拼接。send方法为空参 ​ * post方式，请求参数在send方法中定义 ​ 2. 请求的URL： ​ 3. 同步或异步请求：true（异步）或 false（同步） ​ */ xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true); ​ //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() { //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); } } JSON： 概念： JavaScript Object Notation JavaScript对象表示法 json现在多用于存储和交换文本信息的语法 进行数据的传输 JSON 比 XML 更小、更快，更易解析。 Person p = new Person(); p.setName(\"张三\"); p.setAge(23); p.setGender(\"男\"); var p = {\"name\":\"张三\",\"age\":23,\"gender\":\"男\"}; 语法 基本规则 数据在名称/值对中：json数据是由键值对构成的 键用引号(单双都行)引起来，也可以不使用引号 值得取值类型： 1.数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） {“address”:{“province”：”陕西”….}} null 数据由逗号分隔：多个键值对由逗号分隔 - 花括号保存对象：使用{}定义json 格式 方括号保存数组：[] 获取数据: json对象.键名 json对象[“键名”] 数组对象[索引] 遍历 //1.定义基本格式 var person = {\"name\": \"张三\", age: 23, 'gender': true}; var ps = [{\"name\": \"张三\", \"age\": 23, \"gender\": true}, {\"name\": \"李四\", \"age\": 24, \"gender\": true}, {\"name\": \"王五\", \"age\": 25, \"gender\": false}]; //获取person对象中所有的键和值 //for in 循环 ​ /* for(var key in person){ ​ //这样的方式获取不行。因为相当于 person.\"name\" ​ //alert(key + \":\" + person.key); ​ alert(key+\":\"+person[key]); ​ }*/ ​ ​ //获取ps中的所有值 ​ for (var i = 0; i &lt; ps.length; i++) { ​ var p = ps[i]; ​ for(var key in p){ ​ alert(key+\":\"+p[key]); ​ } ​ } ~~~ JSON数据和Java对象的相互转换 JSON解析器： - 常见的解析器：Jsonlib，Gson，fastjson，jackson JSON转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class) Java对象转换JSON 使用步骤： 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 转换方法： writeValue(参数1，obj): 参数1：File：将obj对象转换为JSON字符串，并保存到指定的文件中Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 writeValueAsString(obj):将对象转为json字符串 注解： @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化 @JsonFormat(pattern = “yyyy-MM-dd”) 复杂java对象转换 List：数组 Map：对象格式一致 案例校验用户名是否存在 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为\"json\" 2. 在服务器端设置MIME类型 response.setContentType(\"application/json;charset=utf-8\");","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://Yogaguo.github.io/tags/AJAX/"}]},{"title":"2019-10-17","slug":"2019-10-17","date":"2019-10-17T13:43:04.000Z","updated":"2020-05-31T08:05:27.610Z","comments":true,"path":"2019/10/17/2019-10-17/","link":"","permalink":"https://Yogaguo.github.io/2019/10/17/2019-10-17/","excerpt":"类加载机制顺序及具体细节首先知道，类从被加载到虚拟机内存中开始，到卸载出内存，整个生命周期包括：加载 (Loading) 验证（Verification）","text":"类加载机制顺序及具体细节首先知道，类从被加载到虚拟机内存中开始，到卸载出内存，整个生命周期包括：加载 (Loading) 验证（Verification） 准备（Preparation）解析（Resolution）初始化（Initialization）使用（Using）卸载（Unloading; 其中 验证 准备 解析 统称为 链接（Linking) 什么时候进行初始化 1.遇到 new getstatic 等 4条字节码指令时，如果类没有进行初始化，则先初始化。 2.使用反射调用时。 3.父类还没有进行初始化时，先触发父类初始化 4.","categories":[],"tags":[]},{"title":"设计模式之模板方法总结","slug":"2019-10-16","date":"2019-10-16T11:05:04.000Z","updated":"2020-05-31T09:42:30.484Z","comments":true,"path":"2019/10/16/2019-10-16/","link":"","permalink":"https://Yogaguo.github.io/2019/10/16/2019-10-16/","excerpt":"模板方法定义模板方法模式(template method pattern:定义一个操作中的某种算法的框架，而将一些步骤延迟到子类中。","text":"模板方法定义模板方法模式(template method pattern:定义一个操作中的某种算法的框架，而将一些步骤延迟到子类中。 模板方法模式使得子类在不改变一个算法结构的前提下，对这些步骤进行一些特定化的定义. 模板方法的程序组成架构 在模板方法模式中，存在一个父类（也可以是父接口），其中包括两类方法：模板放法和步骤方法。 模板方法实现某种算法的方法步骤。而这些步骤都是调用的步骤方法完成的。注意，子类不要重写，为了防止，定义为 final 步骤方法完成模板方法的每个阶段性方法。每个步骤方法完成某一特定的 完成总算法的一部分功能 步骤方法有三种类型：抽象方法 最终方法 钩子方法 抽象方法要求子类必须要实现的方法，是完成模板方法的算法步骤中必须由子类完成的个性化定义 最终方法子类不能重写的方法，是：若要完成模板方法的算法步骤，对于所有子类执行都一样的步骤 钩子方法是父类给的默认实现，子类可以重写，通常在父类中给出的是一个空实现，并以该空实现作为方法的默认实现，钩子方法 也可以提供一个非空的的默认实现 具体案例展示package Dome; public abstract class Shopping { //模板方法 public final void buyGoods() { userLogin(); buy(); pay(); } //子类不能重写的方法 public final void userLogin() { System.out.println(\"用户登录\"); } //子类必须实现 public abstract void buy(); //钩子方法 public void pay() { System.out.println(\"使用微信支付\"); } } class ShoesShopping extends Shopping{ @Override public void buy() { System.out.println(\"购买运动鞋\"); } } class ClothesShopping extends Shopping{ @Override public void buy() { System.out.println(\"购买衣服\"); } public void pay() { System.out.println(\"使用支付宝支付\"); } } package Dome; public class Test { public static void main(String[] args) { Shopping shoes = new ShoesShopping(); shoes.buyGoods(); System.out.println(\"==================\"); Shopping clothes = new ClothesShopping(); clothes.buyGoods(); } } 输出结果： 用户登录 购买运动鞋 使用微信支付 ================== 用户登录 购买衣服 使用支付宝支付 扩展 在 JDK 的集合源码中 ArrayList 就是用了模板方法模式设计的。 ArrayList继承自 AbstractList 抽象类 ，而 AbstractList 有继承自 AbstractCollection","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://Yogaguo.github.io/categories/设计模式/"}],"tags":[{"name":"模板方法","slug":"模板方法","permalink":"https://Yogaguo.github.io/tags/模板方法/"}]},{"title":"Test","slug":"Test","date":"2019-10-06T05:15:50.000Z","updated":"2020-05-31T08:05:28.091Z","comments":true,"path":"2019/10/06/Test/","link":"","permalink":"https://Yogaguo.github.io/2019/10/06/Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JVM内存模型与GC算法策略","slug":"Demo2019-9-29","date":"2019-09-29T08:09:57.000Z","updated":"2020-05-31T12:12:02.823Z","comments":true,"path":"2019/09/29/Demo2019-9-29/","link":"","permalink":"https://Yogaguo.github.io/2019/09/29/Demo2019-9-29/","excerpt":"","text":"JVM Run-Time Data Area 运行时数据区在学习后文，先展示 JVM RunTime Data Area大致布局图和JVM Stacks图 JVM Stacks Java虚拟机栈首先要知道，栈是操作系统内核为某个进程或者线程建立的存储区域，它保存着一个线程中的方法的调用状态，它 具有先进后出的特性。在栈中的数据大小与生命周期都是确定的，在方法执行完成后退出栈后，它的生命周期也就 结束了。 Java虚拟机栈是JVM建立的，根据《深入理解Java虚拟机》，JVMS(虚拟机栈)是线程私有的。它的生命周期与线程相同 注意：Java中每个方法对应一个Frame(栈帧)，每个Frame中都有Local Variables(局部变量表)，Operand Satcks(操作数栈)，Dynamic Linking(动态链接),Return Address(方法出口)。每一个方法从调用到到执行完毕，就是一个Frame在JVMS 中入栈到出栈的过程。 图解Frame中方法的一次执行过程 public static void main(String[] args) { int i = 10; } 这一段代码发生什么？ 首先看Frame中Local Variables和Operand Stack的指令图 由图看出 main线程栈中经历了 ： 1.指令 ipush 把100 压如操作数栈，istore 1 把栈顶元素放到局部变量表中索引为 1 的区域，注意：局部变量表有两个参数，args 和 i public void add(int a,int b){ int c= a+b; } 还是首先看Frame中Local Variables和Operand Stack的指令图 add 线程栈经历了： 1.指令 iload1 iload2 把提前已经在 a 和 b 的值从 操作数栈中放到 局部变量表中中索引为 1 2的区域，iadd 把a和b相加放到局部变量表的栈顶 ，istore3 把 7 弹出放到 c 中 return 结束 PC Register 程序计数器程序计数器是一块小的内存空间，它的功能：记录当前线程执行地址，每一个线程都有一个PC 寄存器，即它为线程私有。 为什么需要PC计数器： Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间实现的。因此，为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的PC计数器。 Native Method Area本地方法栈用来调用其他语言的本地方法，比如C / C++ 写得本地代码，这些方法在本地方法栈执行，而不会再Java栈中执行。它也是线程私有的。 Java HeadJava虚拟机管理的内存中最大的一块，是所有线程共享的，几乎所有的对象实例都在这里分配。（有些小的对象有可能不在这分配，后面再说）。Java堆是垃圾收集器管理的主要区域。从内存回收角度看：现在的收集器基本都采用分代收集算法，所以Java堆还可以被分为：新生代和老年代：在细致-&gt; Eden区 两个Survivor区（1:1） Tenured(终身区)，关于垃圾回收，随后说。 Method Area 方法区与Java堆一样，是线程共享的，用于存储已被Java虚拟机加载的类信息 常量 静态变量 编译器编译后的代码。JVM运行时，类加载器子系统将会提取 class 文件里的类信息，并将其放到Method Area中， RunTime Constant Pool 运行时常量池Method Area中的一部分，用于存放编译期生成的各种字面量和符号引用。除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时的常量池中。关于运行时常量池的详解。在学习完类加载顺序后再说明。 GC算法分配策略首先看一张Heap中从内存回收角度的分布图： 现在来解释： 首先 eden 区和 Survivor区比例为 8：1:1，至于为何，应该是经过多次试验，这样分配最好吧，后期可以调参，新生代产生的垃圾比较多，Old 老年代产生的相对少。所以新生代多使用 Copying 复制垃圾回收算法。老年代多使用 Mark Compact 标记整理算法。至于为何。看下文！ GC 过程 当 new 了一个对象。如果JVM检测到它“ 很大 ”，何为大对象：需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组，它们会被直接放到Old老年代。 在正常的情况下： 对象优先先放到Eden,如果不需要它了，GC，如果发现有的引用还指向它。把这个对象 Copy 到Survivor区中的S0 S1中的一个，比如S0 GC开始 如果发现S0中这个对象不存在了，直接回收，如果依然存在，在 Copy 到 S1 中 在来一次 GC ,发现它在 S1 中还存在(需要生存),又 Copy 到 S0 中，循环往复 15次，发现对象一直存在，直接放到Old区。 什么是 垃圾对象（如何确定它）一句话，未来不会再被用的对象，如何确定它？ 引用计数： 对象会有一个对象头，有一个引用计数器，默认为 0 ，来一个引用，计数器加 1 ，当引用失效，计数器就减 1 ，当减为 0 时，为 垃圾 ——&gt;GC; 缺点：很明显，它很容易因为对象之间相互循环引用，最终造成Memory Leak. Root Searching 根搜索 正向可达 Searching from the roots instance Which instance is roots instance? ​ JVM Stacks引用的对象 Native Method Stacks 引用的对象 RunTime Constant Pool 常量池中引用引用的对象 Static reference in method area 引用的对象 实现： 根据这些跟对象传出的引用去找，看有什么对象可以找到，能找到(可达）的都不是垃圾，反之是垃圾 如何清除垃圾 1.Mark-Sweep 标记-清除： 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 它很简单，但是有两点不足：一是效率不高，二是带来了内存碎片化问题 2.Copying 复制算法 事先准备两块大小相等的内存，每次只使用一块，当这一块使用完了，将还存活的对象复制到另一块中，在清除已使用过的内存空间。很明显，内存浪费。 3.Mark-Compact 标记-整理 标记过程与 “ 标记 清除” 一样，但后续中：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 再谈Java对象的分配 1.一个小的对象，在JDK1.8之后，会首先放到栈上 放到栈上的对象具备以下特征：1.线程私有化的 2.无逃逸（一个对象只有这个这个方法用，其他方法没有用）3.支持标量替换。 栈上分配的好处：自动回收（弹栈）。 2.栈上不能分配了，或者它逃逸了，那么会被分配到线程本地TLAB(位于堆的Eden区，占用Eden的 1% 的空间)，它的优点在于：多线程下，小对象不用竞争eden区就可以申请空间，提高了效率。 3.看是否是 大对象，是的话，直接 Old 老年代。 4.不是，进入Eden ​","categories":[{"name":"JVM","slug":"JVM","permalink":"https://Yogaguo.github.io/categories/JVM/"}],"tags":[{"name":"JVM内存模型","slug":"JVM内存模型","permalink":"https://Yogaguo.github.io/tags/JVM内存模型/"},{"name":"GC","slug":"GC","permalink":"https://Yogaguo.github.io/tags/GC/"}]},{"title":"JSP与Session初学","slug":"Demo2019-9-21","date":"2019-09-21T09:40:14.000Z","updated":"2020-05-31T12:12:22.134Z","comments":true,"path":"2019/09/21/Demo2019-9-21/","link":"","permalink":"https://Yogaguo.github.io/2019/09/21/Demo2019-9-21/","excerpt":"","text":"JSP入门：概念 1.Java Server Pages:Java服务器端页面，可以理解为：一个特殊的页面，其中即可以指定html标签，又可以定义java代码，它的作用就是为了简化书写 原理 JSP本质就是Servlet,在之前的Servlet中，输出页面标签是由我们自己完成，而在JSP中，它的源码中已经帮我们提前做了html标签的输出 out.write(&quot;标签语句&quot;) JSP的脚本 JSP的脚本就是：JSP定义Java代码的方式 如： &lt;% System.out.println(\"hello\") %> 脚本学习 1.&lt;% 代码 %&gt; ​ 它定义的Java代码在转换成.Java文件中的service()方法中，它可以定义servlet()方法中定义的一切 2.&lt;%！代码 %&gt; ​ 它定义的Java代码，在JSP转化后的Java类中的成员位置中（也就是说可以定义成员变量，成员方法，静态代码块。。。），但是它用的比较少，因为之前说过，在Servlet中，尽量不要定义成员变量等等，因为可能引发线程安全的问题 3.&lt;%= 代码 %&gt; ​ 它定义的Java代码会输出到页面上。也就是说，Java输出语句中可以定义什么，该脚本就可以定义什么 JSP的内置对象 概念：在JSP页面中不需要获取和创建，可以直接使用的对象 JSP共有9个内置对象 先说三个： 1.Request 2.Response 3.out:字符输出流对象，可以将数据输出到页面上，和response.getWrite()类似 response.getWrite()和out.write的区别： 在Tomcat服务器真正给客户端浏览器做出响应之前，会先找response缓冲区的数据，找到后拼到响应体中，在找out缓冲区数据，所以，response.getWrite()数据输出永远都在out.write()之前 Session概念 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器的对象中。（HttpSession） 入门学习 1.HttpSession域对象： HttpSession session = request.getSession() 2.使用HttpSession对象 Object getAttribute(String name) void setAttribute(String name,Object value) Session的原理：Session的实现是依赖于Cookie的 Session细节 1.当客户端关闭后，服务器不关闭，两次获取的session不是同一个 ​ 默认情况下，当客户端浏览器关闭后，即一次会话结束，那么获取不到对应的cookie头 如果需要session相同，可以创建Cookie，键为JSESSIONID,设置最大存活时间，让cookie持久化保存 Cookie c= new Cookie(\"JSESSIONID\",session.getId()); c.setMaxAge(60*60); resp.addCookie(c); 2.客户端不关闭，服务器关闭后，两次获取的session不是同一个 ​ 服务器关闭，内存中创建的session对象就会被销毁，下一次只会创建新的session对象，但是，虽然对象不是同一个，但是要确保数据不丢失 1.session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上 2.session的活化;在服务器启动后，将session文件转化为内存中的session对象 注意：本地的Tmocat会自动完成session对象的序列化和反序列化，而IDEA不会，它只会将sesion对象序列化 3.session的失效时间 1.服务器关闭 session对象调用invalidate(),自杀 session对象默认失效时间 30min，可以选择性的修改 &lt;session-config> &lt;session-timeout>30&lt;/session-timeout> &lt;/session-config> Session的特点 1.session是用于存储一次会话的多次请求的数据，存在于服务器端 2.session可以存储任意类型，任意大小的数据 Session与Cookie的区别 1.session存储数据在服务器端，cookie在客户端 2.session没有数据大小限制，cookie有 3.session数据安全（服务器端相对安全），cookie相对不安全 session案例 1.案例需求： 1.访问带有验证码的登录页面login.jsp 2.用户输入用户名，密码以及验证码 如果用户名和密码错误，跳转到登录页面，提示：用户名或密码错误 如果验证码输入有误，跳转到登录页面，提示：验证码错误 都正确，跳转到主页success.jsp,显示：用户名 欢迎您 生成验证码package cn.Yogaguo.session.Case; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.*; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; @SuppressWarnings(\"all\") @WebServlet(\"/checkcode\") public class CheckCodeServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生成随机角标 Random ran = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 sb.append(ch); //2.3写验证码 g.drawString(ch+\"\",width/5*i,height/2); } String checkCode_session = sb.toString(); //将验证码存入session request.getSession().setAttribute(\"checkCode_session\",checkCode_session); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { g.setColor(Color.GREEN); int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); } //3.将图片输出到页面展示 ImageIO.write(image,\"jpg\",response.getOutputStream()); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 登录package cn.Yogaguo.session.Case; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.util.Map; @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.设置request编码 request.setCharacterEncoding(\"utf-8\"); //2.获取参数 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String checkCode = request.getParameter(\"checkCode\"); //3.先获取生成的验证码 HttpSession session = request.getSession(); String checkCode_session = (String) session.getAttribute(\"checkCode_session\"); //删除session中存储的验证码 session.removeAttribute(\"checkCode_session\"); //3.先判断验证码是否正确 if(checkCode_session!= null &amp;&amp; checkCode_session.equals(checkCode)){ //忽略大小写比较 //验证码正确 //判断用户名和密码是否一致,需要调用UserDao查询数据库 if(\"zhangsan\".equals(username) &amp;&amp; \"123\".equals(password)){ //登录成功 //存储信息，用户信息 session.setAttribute(\"user\",username); //重定向到success.jsp response.sendRedirect(request.getContextPath()+\"/success.jsp\"); }else{ //登录失败 //存储提示信息到request request.setAttribute(\"login_error\",\"用户名或密码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } }else{ //验证码不一致 //存储提示信息到request request.setAttribute(\"cc_error\",\"验证码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 登录页面&lt;%-- Created by IntelliJ IDEA. User: LENOVO Date: 2019/9/24 Time: 15:42 To change this template use File | Settings | File Templates. --%> &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>login&lt;/title> &lt;script> window.onload = function () { document.getElementById(\"img\").onclick = function () { this.src=\"/cookie&amp;session/checkcode?time=\"+new Date().getTime(); } } &lt;/script> &lt;style> div{ color: red; } &lt;/style> &lt;/head> &lt;body> &lt;form action=\"/cookie&amp;session/loginServlet\" method=\"post\"> &lt;table> &lt;tr> &lt;td>用户名&lt;/td> &lt;td>&lt;input type=\"text\" name=\"username\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>密码&lt;/td> &lt;td>&lt;input type=\"password\" name=\"password\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>验证码&lt;/td> &lt;td>&lt;input type=\"text\" name=\"checkCode\">&lt;/td> &lt;/tr> &lt;tr> &lt;td colspan=\"2\">&lt;img id=\"img\" src=\"/cookie&amp;session/checkcode\">&lt;/td> &lt;/tr> &lt;tr> &lt;td colspan=\"2\">&lt;input type=\"submit\" value=\"登录\">&lt;/td> &lt;/tr> &lt;/table> &lt;/form> &lt;div>&lt;%=request.getAttribute(\"cc_error\") == null ? \"\" : request.getAttribute(\"cc_error\")%>&lt;/div> &lt;div>&lt;%=request.getAttribute(\"login_error\") == null ? \"\" : request.getAttribute(\"login_error\") %>&lt;/div> &lt;/body> &lt;/html> 登录成功页面&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>&lt;html>&lt;head> &lt;title>Title&lt;/title>&lt;/head>&lt;body> &lt;h1>&lt;%= request.getSession().getAttribute(\"user\")+\"，欢迎您！\"%>&lt;/h1>&lt;/body>&lt;/html>","categories":[{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/categories/Web/"}],"tags":[{"name":"Session","slug":"Session","permalink":"https://Yogaguo.github.io/tags/Session/"}]},{"title":"Cookie会话技术的学习笔记","slug":"Demo2019-9-18","date":"2019-09-18T08:41:58.000Z","updated":"2020-05-31T12:12:33.205Z","comments":true,"path":"2019/09/18/Demo2019-9-18/","link":"","permalink":"https://Yogaguo.github.io/2019/09/18/Demo2019-9-18/","excerpt":"","text":"会话技术 1.会话： 一次会话中包含多次请求和响应。 1.一次会话: 浏览器第一次给服务器资源发送请求，会话建立，访问服务器，直到有一方断开为止。 作用：在一次会话的范围内的多次请求间共享数据(HTTP是无状态的，每一次建立的请求和响应都是独立的，即不和其他请求响应进行交互，会话技术则解决了此问题) 方式： 1.客户端会话技术：Cookie 2.服务器端会话技术：Session Cookie: 概念：客户端会话技术，将数据保存到客户端 快速入门 1.使用步骤： 1.创建Cookie对象，绑定数据 new Cookie(String name,String value) 2.客户端发送Cookie对象 给浏览器 response.addCookie(Cookie cookie) 3.获取Cookie，服务器拿到数据 Cookie[] request.getCookie() Cookie实现原理基于响应头set-cookie和请求头cookie实现 Cookie的细节 1.一次可不可以发送多个cookie? 可以，创建多个Cookie对象，发送多个键值对的数据 cookie在浏览器保存多长时间？ 1.默认情况下，当浏览器被关闭，Cookie数据被销毁（默认情况：Cookie存于浏览器内存） 2.设置Cookie生命周期，让它持久化存储： setMaxAge(int seconds) 1.正数：将Cookie数据写到硬盘中，持久化存储，也代表Cookie的存活时间 2.负数（默认值） 3.零：代表删除Cookie信息 cookie可以存中文？ 在Tomcat 8 之前，Cookie不能直接存储中文数据 在Tomcat 8 之后，支持中文,但是，对于一些特殊字符还是不支持，用URL编码存储，URL解码 cookie获取范围有多大？ 假设在一个Tmocat服务器中，部署了多个web项目，这些web项目中cookie能不能共享 默认情况下，cookie不能共享 setPath(String path) //设置cookie的获取范围，默认下，设置当前的虚拟目录 如果要共享 setPath(&quot;/&quot;) 不同的tomcat服务器间cookie的共享问题：setDomain(String path) 如果设置一级域名相同，那么多个服务器之间cookie共享 setDomain(&quot;.baidu.com&quot;),那么，tieba.baidu.com和news.baidu.com中的cookie就可以共享 Cookie的特点和作用特点 1.Cookie存储数据在客户端浏览器 2.浏览器对单个cookie的大小有限制，以及，对同一个域名下的总cookie数量也有限制(20个) 作用 cookie一般用于存储少量不太敏感的数据 在不登录的情况下，来完成服务器对客户端的身份识别 Cookie小案例：记住上一次访问的时间 1.访问一个Servlet,如果是第一次访问，则提示：您好，欢迎您首次访问。 2.如果不是第一次访问，则提示：欢迎回来，您上次访问时间为：显示时间字符串 分析 1.可以采用Cookie来完成 2.在服务器中的Servlet判断是否有一个名为lastTime的cookie 1.有：不是第一次访问，响应数据：（欢迎回来，您上次访问时间为xxxxxx）,在写回Cookie 2.没有：是第一次访问，响应数据（您好，欢迎首次访问），再写回Cookie(lastTime=xxxxx) 代码package cn.Yogaguo.cookieCase; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; import java.util.logging.SimpleFormatter; /** - 2.在服务器中的Servlet判断是否有一个名为lastTime的cookie - 1.有：不是第一次访问，响应数据：（欢迎回来，您上次访问时间为xxxxxx）,在写回Cookie - 2.没有：是第一次访问，响应数据（您好，欢迎首次访问），再写回Cookie(lastTime=xxxxx) */ @WebServlet(\"/cookieTest\") public class CookieTest extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { boolean flag = false; //设置响应的消息体的数据格式和编码 resp.setContentType(\"text/html;charset=utf-8\"); //获取所有的cookie Cookie[] cookies = req.getCookies(); //遍历cookies数组 if(cookies != null &amp;&amp; cookies.length > 0){ for(Cookie c :cookies){ //获取cookie的名称 String name = c.getName(); //判断是否有lastTime if(\"lastTime\".equals(name)){ flag = true; //获取当前时间的字符串，重新设置cookie的值，再重新发送cookie Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str = simpleDateFormat.format(date); str = URLEncoder.encode(str,\"utf-8\"); //响应数据 String value = c.getValue(); //URL解码 value = URLDecoder.decode(value,\"utf-8\"); resp.getWriter().write(\"&lt;h1>欢迎回来，您上次访问时间为:\"+value+\"&lt;/h1>\"); c.setValue(str); //设置cookie的存活时间 一个月 c.setMaxAge(60*60*24*30); resp.addCookie(c); break; } } } if(cookies == null || cookies.length == 0 || flag == false){ Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str = simpleDateFormat.format(date); str = URLEncoder.encode(str,\"utf-8\"); Cookie cookie = new Cookie(\"lastTime\",\"str\"); cookie.setMaxAge(3600*24*30); resp.addCookie(cookie); resp.getWriter().write(\"&lt;h1>您好，欢迎您首次访问\"); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } ​ ​ ​","categories":[{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/categories/Web/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://Yogaguo.github.io/tags/Cookie/"}]},{"title":"一个空格引发的bug","slug":"Demo2019-9-17","date":"2019-09-17T12:44:16.000Z","updated":"2019-10-04T11:38:59.802Z","comments":true,"path":"2019/09/17/Demo2019-9-17/","link":"","permalink":"https://Yogaguo.github.io/2019/09/17/Demo2019-9-17/","excerpt":"","text":"今天在Tomcat部署本地图片，通过浏览器访问，但是，在html中写好图片超链接后，点击发现报错 500 。。 那就代表Tomcat服务器内部有错误，在看看server log ,发现是 Tomcat内部访问不到图片，但是我的图片就在web目录下(IDEA),在本地查看，D:\\IntelliJIDEA2018\\TestLogin\\out\\artifacts\\TestLogin_war_exploded下也有(这是部署的项目的服务器路径)，弄了好长时间，最后竟然是因为 在html中写图片的超链接时路径多了空格，所以浏览器地址栏显示20%!!! 表示有空格，改过来，重启Tomcat即可 PS: 真实心酸血泪史呀","categories":[{"name":"采坑","slug":"采坑","permalink":"https://Yogaguo.github.io/categories/采坑/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://Yogaguo.github.io/tags/Tomcat/"}]},{"title":"Response对象的学习及案例","slug":"demo7","date":"2019-09-17T10:41:42.000Z","updated":"2020-05-31T12:09:41.524Z","comments":true,"path":"2019/09/17/demo7/","link":"","permalink":"https://Yogaguo.github.io/2019/09/17/demo7/","excerpt":"","text":"1. HTTP协议：响应消息 2. Response对象 3. ServletContext对象HTTP协议：1. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体 2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常)​​ 2. 响应头：​ 1. 格式：头名称： 值​ 2. 常见的响应头：​ 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式​ 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据​ * 值：​ * in-line:默认值,在当前页面内打开​ * attachment;filename=xxx：以附件形式打开响应体。文件下载​ 3. 响应空行​ 4. 响应体:传输的数据 * 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html> &lt;head> &lt;title>$Title$&lt;/title> &lt;/head> &lt;body> hello , response &lt;/body> &lt;/html> Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(\"/day15/responseDemo2\"); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a> , &lt;form> 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 ​​ 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(\"text/html;charset=utf-8\"); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(\"/b.txt\");//web目录下资源访问 System.out.println(b); String c = context.getRealPath(\"/WEB-INF/c.txt\");//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//src目录下的资源访问 System.out.println(a); 案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx* 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;a href=\"/day14_test/imgs/1.avi\">视频&lt;/a> &lt;a href=\"/day14_test/imgs/1.jpg\">图片&lt;/a> &lt;hr> &lt;a href=\"/day14_test/downLoadServlet?filename = 1.avi\">视频&lt;/a> &lt;a href=\"/day14_test/downLoadServlet?filename = 1.jpg\">图片&lt;/a> &lt;/body> &lt;/html> @SuppressWarnings(\"all\") @WebServlet(\"/downLoadServlet\") public class downLoadServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求参数，文件名称 String filename = request.getParameter(\"filename\"); //2.使用字节输入流加载文件进内存 //2.1找到文件服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath(\"/imgs/\" + filename); //注意 imgs文件放在web目录下！！！！ //2.2用字节流关联 FileInputStream fis = new FileInputStream(realPath); //3.设置response的响应头 //3.1设置响应头类型：content-type String mimeType = servletContext.getMimeType(filename);//获取文件的mime类型 response.setHeader(\"content-type\", mimeType); //3.2设置响应头打开方式:content-disposition response.setHeader(\"content-disposition\", \"attachment;filename=\" + filename); //4.将输入流的数据写出到输出流中 ServletOutputStream sos = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while ((len = fis.read(buff)) != -1) { sos.write(buff, 0, len); } fis.close(); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } }","categories":[{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/categories/Web/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Yogaguo.github.io/tags/Servlet/"}]},{"title":"数据库连接池技术与Spring Template","slug":"Demo5-1","date":"2019-09-12T10:17:35.000Z","updated":"2020-05-31T12:13:23.565Z","comments":true,"path":"2019/09/12/Demo5-1/","link":"","permalink":"https://Yogaguo.github.io/2019/09/12/Demo5-1/","excerpt":"","text":"1. 数据库连接池 2. Spring JDBC : JDBC Template数据库连接池1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection * 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); 5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 * 代码： public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); }​ public static void close(ResultSet rs , Statement stmt, Connection conn){​ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } }​ if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } }Spring JDBC* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 * 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 { //Junit单元测试，可以让方法独立执行​ //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } });​ for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } }","categories":[{"name":"mysql","slug":"mysql","permalink":"https://Yogaguo.github.io/categories/mysql/"}],"tags":[{"name":"连接池","slug":"连接池","permalink":"https://Yogaguo.github.io/tags/连接池/"}]},{"title":"Request与Response对象介绍","slug":"Demo5","date":"2019-09-11T10:38:45.000Z","updated":"2020-05-31T12:09:24.229Z","comments":true,"path":"2019/09/11/Demo5/","link":"","permalink":"https://Yogaguo.github.io/2019/09/11/Demo5/","excerpt":"","text":"Servlet体系结构Servlet-- 接口 | GenericServlet-- 抽象类 | HttpServlet-- 抽象类 GernericServlet:将Servlet接口中的方法做了默认空实现，只将Service()方法作了抽象，将来定义Servlet类时，可以继承GernericServlet，实现Service() HttpServlet:对http协议的一种封装，为了简化操作 定义类继承HttpServlet 复写doGet()/doPost() Servlet相关配置 urlpartten:Servlet访问路径：一个Servlet可以定义多个访问路径 @WebServlet({&quot;/demo05&quot;,&quot;/demo005&quot;}) 路径的定义规则 1 /xxx 2 /xxx/xxx:多层路径 3 .do(为通配符) HTTP: 概念：Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式 HTTP协议特点： 1 基于TCP/IP的高级协议 2 默认端口为80 3 基于请求/响应模型：一次请求对应一次响应 4 无状态协议：每次请求之间相互独立，不能交互数据 请求消息数据格式请求行 请求方式 请求url 请求协议/版本 GET/Demo.html HTTP/1.1 HTTP有7中请求方式，常用的由2中 GET:==请求参数在请求行中==，即在url后,请求的url是有限制的，不太安全 Post:==请求参数在请求体中==，请求的url没有限制，相对安全请求头请求头名称:请求头值 常见的请求头 User-Agent:浏览器告诉服务器，我访问你使用的浏览器版本信息 Referer:http://localhost/index.html-&gt; 告诉服务器，我（当前请求）从哪里来 防止别人盗取链接 做些统计的工作请求空行 空行：分割Post请求的请求头和请求体的 请求体（正文） 封装Post请求消息的请求参数的 POST /index.html HTTP/1.1 Host: localhost:8888 Connection: keep-alive Content-Length: 25 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: null Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8,en-US;q=0.7,en;q=0.6 uname=yogaguo Requsetrequest和response对象的基本原理 1 requset和response对象是由服务器创建的，我们只是使用 2 request对象是获取请求消息，response对象是设置响应消息的 request对象继承体系结构ServletRequest --接口 | HttpServletRequest --接口 | 实现 org.apache.catalina.connector.RequestFacade(类)request功能 1 获取请求消息数据 获取请求行数据:Get/TestDemo02/demo02?name=yogaguo HTTP/1.1 方法： 1.获取请求方式：String getMethod() ==2.获取虚拟目录==(TestDemo02)String getContextPath 3.获取Servlet路径(/demo02)String ServletPath() 4.获取Get方式的请求参数String getQueryString 5.==获取请求的url== /TestDemo02/demo02) String getRequestURI():返回的是 /TestDemo02/demo,==StringBuffer getRequestURL()==,返回的是http://localhost/TestDemo02/demo02 URL:统一资源定位符：http://loclahost/TestDemo02/demo02 URI:统一资源标识符：/TestDemo02/demo02 6.获取客户机的IP地址：String getRemoteAddr() 获取请求头数据: 1==String getHeader(String name)== 通过请求头的名称获取请求头的值 2 Enumeration&lt;String&gt; getHeaderNames() :获取所有请求头的名称 (Enumeration类似迭代器) 获取请求体数据 只有==Post==请求方式才有请求体;在请求体中封装了Post请求的请求参数 获取步骤： 1.获取流对象 1.BufferedReader getReader() ,获取字符输入流 2.ServletInputStream getInputStream() ,获取字节输入流 2.再从流对象中拿数据 BufferedReader reader=req.getReader(); String line=null; while((line=reader.readLine())!=null){ System.out.println(line); } 其他方法： 1.获取请求参数的通用方法 String getParamater(String name):根据参数名获取参数值；String getParameterValues(String name):根据参数名获取参数值的数组 Enumeration&lt;String> parameterNames=req.getParameterNames(); while(parameterNames.hasMoreElements()){ String name= parameterNames.nextElement(); System.out.println(name); String value=req.getParameter(name); System.out.println(value); System.out.println(\"---------------------\"); } {% asset_img 6.jpg %} 中文乱码问题： Get方式：Tomcat8已经将中文乱码问题解决了 Post方式：会乱码，解决办法，在获取参数时，设置request的编码req.setCharacterEncoding(&quot;utf-8&quot;); 2.请求转发:一种在服务器内部的资源跳转方式 步骤 1.通过request对象获取请求转发器对象: RequestDispatcher getRequestDispatcher(String path) 2.通过RequestDispatcher对象来进行转发：forward(ServletRequest request,ServletResponse response) 转发特点： 1.浏览器地址栏路径不发生变化 2.只能转发到当前服务器内部的资源中 3.转发是一次请求 @WebServlet(\"/requestDemo7\") public class RequestDemo07 extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"demo7被访问了。。。\"); //转发到demo8资源 req.getRequestDispatcher(\"/requestDemo8\").forward(req,resp); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req,resp); } } @WebServlet(\"/requestDemo8\") public class RequestDemo08 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"Demo8被访问了\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } demo7被访问了。。。 Demo8被访问了 3.共享数据: 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，所以request域一般用于请求转发的多个资源中取共享数据== 方法： 1.setAttribute(String name,Object obj):存储数据 2.Object getAttribute(String name):通过键获取值 3.void removeAttribute(String name):通过键移除键值对 4.获取ServletContext 案例：用户登录编写login.html登录页面 ```html &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;form action=\"/day14_test/loginServlet\" method=\"post\"> &lt;input type=\"text\" name=\"username\">&lt;br> &lt;input type=\"password\" name=\"password\">&lt;br> &lt;input type=\"submit\" value=\"登录\"> &lt;/form> &lt;/body> &lt;/html> ``` 使用Druid数据库连接池技术，操作mysql ```java package cn.Yogaguo.dao.Utils; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; @SuppressWarnings(\"all\") /** * JDBC的工具类，使用的是Druid连接池 */ public class JDBCUtils { private static DataSource ds; static { Properties properties = new Properties(); try { //加载配置文件 properties.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 获取连接Connection对象 */ public static DataSource getDataSource(){ return ds; } } ``` 使用JDBCTemplate技术封装JDBC ```java package cn.Yogaguo.dao; import cn.Yogaguo.dao.Utils.JDBCUtils; import cn.Yogaguo.domain.User; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表 */ @SuppressWarnings(\"all\") public class Userdao { /** * 声明JDBCTemplate对象共用 */ private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser，只有用户名和密码 * @return user的全部信息 */ public User login(User loginUser){ try { //编写sql String sql = \"select * from user where username = ? and password = ?\"; //调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User>(User.class), loginUser.getUsername(),loginUser.getPassword()); return user; } catch (DataAccessException e) { return null; } } } ``` 登录成功跳转到SuccessServlet展示：登录成功，用户名，欢迎你 ```java package cn.Yogaguo.web.servlet; import cn.Yogaguo.dao.Userdao; import cn.Yogaguo.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @SuppressWarnings(\"all\") @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置编码 req.setCharacterEncoding(\"utf-8\"); String username = req.getParameter(\"username\"); String password = req.getParameter(\"PASSWORD\"); User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); Userdao dao = new Userdao(); User user = dao.login(loginUser); if(user == null){ req.getRequestDispatcher(\"/failServlet\").forward(req,resp); }else{ req.setAttribute(\"user\",user); req.getRequestDispatcher(\"/SuccessServlet\").forward(req,resp); } } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req,resp); } } ``` 跳转 package cn.Yogaguo.web.servlet; import cn.Yogaguo.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @SuppressWarnings(\"all\") @WebServlet(\"/SuccessServlet\") public class SuccessServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User)req.getAttribute(\"user\"); if(user != null){ //给页面写句话 //设置页面编码 resp.setContentType(\"text/html;charset = utf-8\"); //输出到页面上 resp.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎你\"); } } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req,resp); } } 登录失败，跳转到FailServlet展示：登录失败，用于名或密码错误 package cn.Yogaguo.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @SuppressWarnings(\"all\") @WebServlet(\"/failServlet\") public class FailServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //给页面写句话 //设置页面编码 resp.setContentType(\"text/html;charset = utf-8\"); //输出到页面上 resp.getWriter().write(\"登录失败，用户名或密码错误\"); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req,resp); } }","categories":[{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/categories/Web/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Yogaguo.github.io/tags/Servlet/"}]},{"title":"Servlet与request入门（一)","slug":"Demo33","date":"2019-09-11T10:21:09.000Z","updated":"2020-05-31T12:12:55.044Z","comments":true,"path":"2019/09/11/Demo33/","link":"","permalink":"https://Yogaguo.github.io/2019/09/11/Demo33/","excerpt":"","text":"Servlet 概念：servlet applet,运行在服务器端的小程序,servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则 将来我们自定义一个类，实现复写Servlet接口，复写方法. 快速入门： 1.创建JavaEE的项目 2.定义一个类，实现Servlet接口，实现接口中的抽象方法public class ServletDemo01 implements Servlet 3.配置Servlet，在web.xml中配置 &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.yogaguo.web.servlet.ServletDemo01&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.执行原理: 当服务端接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的标签体内容。如果有，则在找到对应的全类名 tomcat会将字节码文件加载到内存，并且创建其对象 调用其方法 Servlet中的生命周期: 被创建:执行init方法,只执行一次 Servlet什么时候被创建 默认情况下，第一次被访问，Servlet被创建 当然，可以配置Servlet的创建时机 在标签下配置 &lt;servlet&gt; &lt;servlet-name&gt;demo02&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.yogaguo.web.servlet.ServletDemo02&lt;/servlet-class&gt; &lt;!--指定Servlet的创建时机 1.第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数，对应1情况（默认值为-1） 2.在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 --&gt; &lt;load-on-startup&gt;5&lt;/load-on-startup&gt; &lt;/servlet&gt; Servlet的init方法只执行一次，说明了一个Servlet在内存中只存在一个对象，Servlet是单例的,所以，多个用户访问时，可能存在线程安全问题尝试加锁，但是不行，影响了性能,解决办法：尽量不要在Servlet中定义成员变量，即使定义了成员变量，也不要对其修改值，避免并发的操作 提供服务:执行service方法，执行多次每次访问Servlet时，Service方法都会被调用一次 被销毁：执行destory方法，只执行一次Servlet被销毁时执行，即服务器正常关闭时，注意：destory方法在Servlet被销毁之前执行，一般用于释放资源 解决Servlet配置问题 Servlet3.0之后，支持注解配置，可以不需要web.xml 步骤： 1.创建JavaEE的项目,选择Servlet的版本，3.0以上，可以不创建web.xml2.定义一个类，实现Servlet接口3.复写方法4.在类上使用@WebServlet注解，进行配置@WebServlet(urlPatterns = &quot;/资源路径&quot;) IDEA与Tamcat的相关配置 1.IDEA会为每一个tomcat部署的项目单独建立一份配置文件查看控制台的输出log:Using CATALINA_BASE: “C:\\Users\\LENOVO.IntelliJIdea2018.2\\system\\tomcat_Test” 2.工作空间目录和Tomcat部署的web项目 Tomcat真正访问的是“Tomcat部署的web项目，以我电脑为例 D:\\IntelliJIDEA2018\\Test\\out\\artifacts\\TestDemo02_war_exploded”，Tomcat部署的web项目对应着工作空间项目的web目录下的所有资源，而且web-INFO下的classes对应的字节码文件是工作空间src下的Java文件被编译后放到里面的 WEB_INFO目录下的资源不能被浏览器直接访问，所以一般不把一些静态资源放到这下面 在Tomcat如何断点调试使用“小虫子”启动 ​","categories":[{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/categories/Web/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://Yogaguo.github.io/tags/servlet/"}]},{"title":"Web相关知识入门","slug":"Demo2","date":"2019-09-11T09:07:56.000Z","updated":"2020-05-31T12:08:57.486Z","comments":true,"path":"2019/09/11/Demo2/","link":"","permalink":"https://Yogaguo.github.io/2019/09/11/Demo2/","excerpt":"","text":"Web服务入门介绍 web相关概念回顾 web服务器软件:Tomcat Servlet入门学习 web相关概念回顾 1.软件架构 1.C/S:客户端/服务器端 2.B/S:浏览器/服务器端 (重点) 2.资源分类 1.静态资源:所有用户访问后，得到的结果都是一样的,静态资源可以直接被浏览器解析 * 如:html,css,Javascript 2.动态资源:每个用户访问相同资源后，得到的结果可能不一样 ,动态资源被访问后需要先转为静态资源，再返回给浏览器(Response) *如 servlet/jsp,php 3.网络通讯三要素 1.IP:电子设备在网络中的唯一标识 2.端口:应用程序在计算机中的唯一标识 0-65535 3.传输协议:规定了数据传输的规范 1.基础协议: 1.tcp:安全的协议，三次握手确认双方都在线，在进行传输 ，速度稍慢 2.udp:不安全协议，速度快 web服务器软件 1.服务器：安装了服务器软件的计算机 2.服务器软件:接受用户的请求，处理请求，做出响应 web服务器软件：接受用户的请求，处理请求，做出响应 1.在web服务器软件中可以部署web项目，让用户通过浏览器来访问这些项目 2.web容器 3.常见java相关的web服务器软件 1.webLogic:oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的 2.webSphere:IBW公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的 3.JBOSS:JBOSS公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的 4.Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范(servlet/jsp),开源的，免费的 4.JavaEE:Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat:web服务器软件 1.下载: 官网地址 2.安装: 解压压缩包 (注意：安装目录建议不要有中文和空格) 3.卸载: 删除目录就行 4.启动:bin/startup.bat双击该文件 1.访问自己：浏览器输入：(http://localhost:8888)(我自己该的端口号，默认8080) 回车访问 2.访问别人:(http://别人ip:8080) 3.可能遇到的问题: 1.黑窗口一闪而过：没有正确配置JAVA_HOME环境变量 2.启动报错： 1.暴力解决-&gt;找到占用的端口号，并且找到对应进程，杀死该进程. 2.温柔解决:修改自身端口号, conf/server.xml 服务器的主配置文件 注意：改动此文件时先备份，以防改错 &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 5.关闭: 1.bin目录命令窗口直接敲 shutdown/catalina stop 二者都可以,或者直接双击shutdown文件 6.配置: 1.部署项目的方式： 1.直接将项目放到webapps目录下即可 /hello:项目的访问路径—&gt;虚拟目录 2.简单部署：将项目打包成war包,再将war包放置到webapps目录下，war包会自动解压 1.配置conf/server.xml文件 1.在conf\\Catalina\\localhost创建任意名称的xml文件，在文件中编写 1.静态项目和动态项目 1.目录结构 1.Java动态项目的目录结构 项目根目录 WEB-INF目录： web.xml:web项目核心配置文件 class目录：放置字节码文件 lib目录：放置依赖的jar包 将Tomcat集成到IDEA中，并且创建JavaEE的项目,部署项目 Run-&gt;Edit configurations-&gt;Templates-&gt;Tomcat server-&gt;Local 配置Tomcat路径 热部署：保证每次更新资源，Tomcat会自动启动","categories":[{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/tags/Web/"}]}],"categories":[{"name":"spring基础学习","slug":"spring基础学习","permalink":"https://Yogaguo.github.io/categories/spring基础学习/"},{"name":"mysql","slug":"mysql","permalink":"https://Yogaguo.github.io/categories/mysql/"},{"name":"算法","slug":"算法","permalink":"https://Yogaguo.github.io/categories/算法/"},{"name":"Java基础","slug":"Java基础","permalink":"https://Yogaguo.github.io/categories/Java基础/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://Yogaguo.github.io/categories/Java并发编程/"},{"name":"设计模式","slug":"设计模式","permalink":"https://Yogaguo.github.io/categories/设计模式/"},{"name":"Redis","slug":"Redis","permalink":"https://Yogaguo.github.io/categories/Redis/"},{"name":"JVM","slug":"JVM","permalink":"https://Yogaguo.github.io/categories/JVM/"},{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/categories/Web/"},{"name":"采坑","slug":"采坑","permalink":"https://Yogaguo.github.io/categories/采坑/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://Yogaguo.github.io/tags/spring/"},{"name":"mysql","slug":"mysql","permalink":"https://Yogaguo.github.io/tags/mysql/"},{"name":"二叉树","slug":"二叉树","permalink":"https://Yogaguo.github.io/tags/二叉树/"},{"name":"Java","slug":"Java","permalink":"https://Yogaguo.github.io/tags/Java/"},{"name":"哈希","slug":"哈希","permalink":"https://Yogaguo.github.io/tags/哈希/"},{"name":"Java内存模型","slug":"Java内存模型","permalink":"https://Yogaguo.github.io/tags/Java内存模型/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://Yogaguo.github.io/tags/工厂模式/"},{"name":"Redis","slug":"Redis","permalink":"https://Yogaguo.github.io/tags/Redis/"},{"name":"AJAX","slug":"AJAX","permalink":"https://Yogaguo.github.io/tags/AJAX/"},{"name":"模板方法","slug":"模板方法","permalink":"https://Yogaguo.github.io/tags/模板方法/"},{"name":"JVM内存模型","slug":"JVM内存模型","permalink":"https://Yogaguo.github.io/tags/JVM内存模型/"},{"name":"GC","slug":"GC","permalink":"https://Yogaguo.github.io/tags/GC/"},{"name":"Session","slug":"Session","permalink":"https://Yogaguo.github.io/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"https://Yogaguo.github.io/tags/Cookie/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://Yogaguo.github.io/tags/Tomcat/"},{"name":"Servlet","slug":"Servlet","permalink":"https://Yogaguo.github.io/tags/Servlet/"},{"name":"连接池","slug":"连接池","permalink":"https://Yogaguo.github.io/tags/连接池/"},{"name":"servlet","slug":"servlet","permalink":"https://Yogaguo.github.io/tags/servlet/"},{"name":"Web","slug":"Web","permalink":"https://Yogaguo.github.io/tags/Web/"}]}