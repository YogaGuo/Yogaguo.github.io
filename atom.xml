<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鱼儿的技术博客</title>
  
  <subtitle>夏虫不可语冰，井蛙不可语海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Yogaguo.github.io/"/>
  <updated>2019-09-12T10:23:59.950Z</updated>
  <id>https://Yogaguo.github.io/</id>
  
  <author>
    <name>小鱼儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库连接池技术与Spring Template</title>
    <link href="https://Yogaguo.github.io/2019/09/12/Demo5-1/"/>
    <id>https://Yogaguo.github.io/2019/09/12/Demo5-1/</id>
    <published>2019-09-12T10:17:35.000Z</published>
    <updated>2019-09-12T10:23:59.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的</code></pre><pre><code>4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法</code></pre><pre><code>    * 代码：        public class JDBCUtils {            //1.定义成员变量 DataSource            private static DataSource ds ;            static{                try {                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                } catch (IOException e) {                    e.printStackTrace();                } catch (Exception e) {                    e.printStackTrace();                }            }            /**             * 获取连接             */            public static Connection getConnection() throws SQLException {                return ds.getConnection();            }            /**             * 释放资源             */            public static void close(Statement stmt,Connection conn){               /* if(stmt != null){                    try {                        stmt.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }*/               close(null,stmt,conn);            }</code></pre><p>​            </p><pre><code>            public static void close(ResultSet rs , Statement stmt, Connection conn){</code></pre><p>​            </p><pre><code>                if(rs != null){                    try {                        rs.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }</code></pre><p>​            </p><pre><code>                if(stmt != null){                    try {                        stmt.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }            }            /**             * 获取连接池方法             */            public static DataSource getDataSource(){                return  ds;            }        }</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：            import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;            import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;            public class JdbcTemplateDemo2 {                //Junit单元测试，可以让方法独立执行</code></pre><p>​                </p><pre><code>                //1. 获取JDBCTemplate对象                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                /**                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1(){                    //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                }                /**                 * 2. 添加一条记录                 */                @Test                public void test2(){                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                }                /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3(){                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                }                /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4(){                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}                }                /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                    for (Map&lt;String, Object&gt; stringObjectMap : list) {                        System.out.println(stringObjectMap);                    }                }                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() {                        @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException {                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                            emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                            return emp;                        }                    });</code></pre><p>​                </p><pre><code>                    for (Emp emp : list) {                        System.out.println(emp);                    }                }                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6_2(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) {                        System.out.println(emp);                    }                }                /**                 * 7. 查询总记录数                 */                @Test                public void test7(){                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                }            }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 数据库连接池

2. Spring JDBC : JDBC Template&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
      <category term="JDBC" scheme="https://Yogaguo.github.io/categories/JDBC/"/>
    
    
      <category term="连接池" scheme="https://Yogaguo.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Request与Response对象介绍</title>
    <link href="https://Yogaguo.github.io/2019/09/11/Demo5/"/>
    <id>https://Yogaguo.github.io/2019/09/11/Demo5/</id>
    <published>2019-09-11T10:38:45.000Z</published>
    <updated>2019-09-11T10:47:11.444Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h5><pre><code>Servlet-- 接口  |  GenericServlet-- 抽象类  |  HttpServlet-- 抽象类  </code></pre><ul><li>GernericServlet:将Servlet接口中的方法做了默认空实现，只将Service()方法作了抽象，将来定义Servlet类时，可以继承GernericServlet，实现Service()  </li><li>HttpServlet:对http协议的一种封装，为了简化操作  <ul><li>定义类继承HttpServlet  </li><li>复写doGet()/doPost()  <h5 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h5></li></ul></li><li>urlpartten:Servlet访问路径：一个Servlet可以定义多个访问路径  <pre><code>@WebServlet({&quot;/demo05&quot;,&quot;/demo005&quot;})  </code></pre></li><li>路径的定义规则  <ul><li>1 /xxx  </li><li>2 /xxx/xxx:多层路径</li><li>3 <em>.do(</em>为通配符)  <h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP:"></a>HTTP:</h5></li></ul></li><li>概念：<strong>Hyper Text Transfer Protocol 超文本传输协议</strong>  </li><li>传输协议：定义了客户端和服务器端通信时，发送数据的格式  </li><li>HTTP协议特点：<ul><li>1 基于TCP/IP的高级协议  </li><li>2 默认端口为80  </li><li>3 基于请求/响应模型：一次请求对应一次响应  </li><li>4 无状态协议：每次请求之间相互独立，不能交互数据  <h5 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h5><h6 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h6></li></ul></li><li>请求方式  请求url  请求协议/版本  <pre><code>GET/Demo.html HTTP/1.1  </code></pre><ul><li>HTTP有7中请求方式，常用的由2中  <ul><li><strong>GET:==请求参数在请求行中==，即在url后,请求的url是有限制的，不太安全</strong>  </li><li><strong>Post:==请求参数在请求体中==，请求的url没有限制，相对安全</strong><h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6>请求头名称:请求头值  </li></ul></li></ul></li><li>常见的请求头  <ul><li>User-Agent:浏览器告诉服务器，我访问你使用的浏览器版本信息  </li><li>Referer:<a href="http://localhost/index.html-&gt;" target="_blank" rel="noopener">http://localhost/index.html-&gt;</a> 告诉服务器，我（当前请求）从哪里来  <ul><li>防止别人盗取链接</li><li>做些统计的工作<h6 id="请求空行"><a href="#请求空行" class="headerlink" title="请求空行"></a>请求空行</h6></li></ul></li></ul></li><li>空行：分割Post请求的请求头和请求体的  <h6 id="请求体（正文）"><a href="#请求体（正文）" class="headerlink" title="请求体（正文）"></a>请求体（正文）</h6></li><li>封装Post请求消息的请求参数的<img src="/2019/09/11/Demo5/5.jpg"></li></ul><pre><code>   POST /index.html HTTP/1.1Host: localhost:8888Connection: keep-aliveContent-Length: 25Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8,en-US;q=0.7,en;q=0.6uname=yogaguo</code></pre><h5 id="Requset"><a href="#Requset" class="headerlink" title="Requset"></a>Requset</h5><h6 id="request和response对象的基本原理"><a href="#request和response对象的基本原理" class="headerlink" title="request和response对象的基本原理"></a>request和response对象的基本原理</h6><ul><li>1 requset和response对象是由服务器创建的，我们只是使用  </li><li>2 request对象是获取请求消息，response对象是设置响应消息的  </li></ul><h6 id="request对象继承体系结构"><a href="#request对象继承体系结构" class="headerlink" title="request对象继承体系结构"></a>request对象继承体系结构</h6><pre><code>ServletRequest --接口 |  HttpServletRequest --接口  |  实现org.apache.catalina.connector.RequestFacade(类)</code></pre><h6 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a>request功能</h6><ul><li><p>1 获取请求消息数据  </p><ul><li><p>获取请求行数据:<code>Get/TestDemo02/demo02?name=yogaguo HTTP/1.1</code>  </p></li><li><p>方法：  </p><ul><li>1.获取请求方式：<code>String getMethod()</code>  </li><li>==2.获取虚拟目录==(TestDemo02)<code>String getContextPath</code>  </li><li>3.获取Servlet路径(/demo02)<code>String ServletPath()</code>  </li><li>4.获取Get方式的请求参数<code>String getQueryString</code>  </li><li>5.==获取请求的url== <code>/TestDemo02/demo02)</code> <code>String getRequestURI()</code>:返回的是 <code>/TestDemo02/demo</code>,==StringBuffer getRequestURL()==,返回的是<code>http://localhost/TestDemo02/demo02</code>  <ul><li>URL:统一资源定位符：<code>http://loclahost/TestDemo02/demo02</code>  </li><li>URI:统一资源标识符：<code>/TestDemo02/demo02</code></li></ul></li><li>6.获取客户机的IP地址：<code>String getRemoteAddr()</code></li></ul></li><li><p>获取请求头数据:  </p><ul><li>1==String getHeader(String name)== 通过请求头的名称获取请求头的值  </li><li>2 <code>Enumeration&lt;String&gt; getHeaderNames()</code> :获取所有请求头的名称 <strong>(Enumeration<string>类似迭代器)</string></strong></li></ul></li><li><p>获取请求体数据  </p><ul><li>只有==Post==请求方式才有请求体;在请求体中封装了Post请求的请求参数  </li><li>获取步骤：  <ul><li>1.获取流对象  <ul><li>1.<code>BufferedReader getReader()</code> ,获取字符输入流  </li><li>2.<code>ServletInputStream getInputStream()</code> ,获取字节输入流</li></ul></li><li>2.再从流对象中拿数据  <pre><code>BufferedReader reader=req.getReader();String line=null;while((line=reader.readLine())!=null){  System.out.println(line);}  </code></pre></li></ul></li><li>其他方法：  <ul><li>1.获取请求参数的通用方法  <ul><li>String getParamater(String name):根据参数名获取参数值；String getParameterValues(String name):根据参数名获取参数值的数组  </li></ul></li></ul></li></ul><pre><code>Enumeration&lt;String&gt; parameterNames=req.getParameterNames();            while(parameterNames.hasMoreElements()){               String name= parameterNames.nextElement();                System.out.println(name);                String value=req.getParameter(name);                System.out.println(value);                System.out.println(&quot;---------------------&quot;);            }  </code></pre>  <img src="/2019/09/11/Demo5/6.jpg"> <ul><li>中文乱码问题：  <ul><li>Get方式：Tomcat8已经将中文乱码问题解决了</li><li>Post方式：会乱码，解决办法，在获取参数时，设置request的编码<code>req.setCharacterEncoding(&quot;utf-8&quot;);</code></li></ul></li></ul></li></ul></li></ul><ul><li>2.请求转发:一种在服务器内部的资源跳转方式<ul><li>步骤  <ul><li>1.通过request对象获取请求转发器对象: <code>RequestDispatcher getRequestDispatcher(String path)</code>  </li><li>2.通过RequestDispatcher对象来进行转发：<code>forward(ServletRequest request,ServletResponse response)</code>  </li></ul></li><li>==转发特点==：<ul><li>1.==浏览器地址栏路径不发生变化==  </li><li>2.只能转发到当前服务器内部的资源中  </li><li>3.==转发是一次请求==</li></ul></li></ul></li></ul><pre><code>@WebServlet(&quot;/requestDemo7&quot;)public class RequestDemo07 extends HttpServlet {    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(&quot;demo7被访问了。。。&quot;);        //转发到demo8资源        req.getRequestDispatcher(&quot;/requestDemo8&quot;).forward(req,resp);    }    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         this.doPost(req,resp);    }}  @WebServlet(&quot;/requestDemo8&quot;)public class RequestDemo08 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(&quot;Demo8被访问了&quot;);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         this.doGet(req,resp);    }}  demo7被访问了。。。Demo8被访问了</code></pre><ul><li><p>3.共享数据:</p><ul><li>域对象：一个有作用范围的对象，可以在范围内共享数据</li><li>==request域：代表一次请求的范围，所以request域一般用于请求转发的多个资源中取共享数据==  </li><li>方法：  <ul><li>1.setAttribute(String name,Object obj):存储数据  </li><li>2.Object getAttribute(String name):通过键获取值  </li><li>3.void removeAttribute(String name):通过键移除键值对</li></ul></li></ul></li><li><p>4.获取ServletContext  </p><h6 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h6><ul><li><p>用户登录案例需求  </p><ul><li><p>1.编写login.html登录页面  </p></li><li><p>2.使用Druid数据库连接池技术，操作mysql  </p></li><li><p>3.使用JDBCTemplate技术封装JDBC  </p></li><li><p>4.登录成功跳转到SuccessServlet展示：登录成功，用户名，欢迎你  </p></li><li><p>5.登录失败，跳转到FailServlet展示：登录失败，用于名或密码错误</p><p>​     </p></li></ul></li></ul></li></ul><p>​<br>​        </p><p>​    </p><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Servlet体系结构&quot;&gt;&lt;a href=&quot;#Servlet体系结构&quot; class=&quot;headerlink&quot; title=&quot;Servlet体系结构&quot;&gt;&lt;/a&gt;Servlet体系结构&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Servlet-- 接口  
|  
Generic
      
    
    </summary>
    
    
      <category term="Servler" scheme="https://Yogaguo.github.io/categories/Servler/"/>
    
      <category term="request" scheme="https://Yogaguo.github.io/categories/Servler/request/"/>
    
    
      <category term="servlet" scheme="https://Yogaguo.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet与request入门（一)</title>
    <link href="https://Yogaguo.github.io/2019/09/11/Demo33/"/>
    <id>https://Yogaguo.github.io/2019/09/11/Demo33/</id>
    <published>2019-09-11T10:21:09.000Z</published>
    <updated>2019-09-11T10:33:29.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul><li>概念：servlet applet,运行在服务器端的小程序,servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则 </li><li>将来我们自定义一个类，实现复写Servlet接口，复写方法.  <h4 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h4></li><li>1.创建JavaEE的项目  <img src="/2019/09/11/Demo33/01.jpg"></li><li>2.定义一个类，实现Servlet接口，实现接口中的抽象方法<br><code>public class ServletDemo01 implements Servlet</code></li><li>3.配置Servlet，在web.xml中配置 <pre><code>&lt;!--配置Servlet --&gt;  &lt;servlet&gt;      &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;      &lt;servlet-class&gt;cn.yogaguo.web.servlet.ServletDemo01&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;      &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;  </code></pre><ul><li>4.执行原理:  <ul><li>当服务端接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径  </li><li>查找web.xml文件，是否有对应的<url-pattern>标签体内容。如果有，则在找到对应的<servlet-class>全类名  </servlet-class></url-pattern></li><li>tomcat会将字节码文件加载到内存，并且创建其对象  </li><li>调用其方法  <h4 id="Servlet中的生命周期"><a href="#Servlet中的生命周期" class="headerlink" title="Servlet中的生命周期:"></a>Servlet中的生命周期:</h4></li></ul></li></ul></li><li>被创建:执行init方法,只执行一次  <ul><li>Servlet什么时候被创建  <ul><li>默认情况下，第一次被访问，Servlet被创建  </li><li>当然，可以配置Servlet的创建时机    </li></ul>  <strong>在<servlet>标签下配置</servlet></strong>  <pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;demo02&lt;/servlet-name&gt;    &lt;servlet-class&gt;cn.yogaguo.web.servlet.ServletDemo02&lt;/servlet-class&gt;    &lt;!--指定Servlet的创建时机           1.第一次被访问时，创建                * &lt;load-on-startup&gt;的值为负数，对应1情况（默认值为-1）           2.在服务器启动时，创建                * &lt;load-on-startup&gt;的值为0或正整数           --&gt;    &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;&lt;/servlet&gt;  </code></pre></li></ul><strong>Servlet的init方法只执行一次，说明了一个Servlet在内存中只存在一个对象，Servlet是单例的,所以，多个用户访问时，可能存在线程安全问题</strong><br><del>尝试加锁，但是不行，影响了性能</del>,<strong><em>解决办法：尽量不要在Servlet中定义成员变量，即使定义了成员变量，也不要对其修改值，避免并发的操作</em></strong></li><li>提供服务:执行service方法，执行多次<br>每次访问Servlet时，Service方法都会被调用一次</li><li>被销毁：执行destory方法，只执行一次<br>Servlet被销毁时执行，即服务器正常关闭时，<strong>注意：destory方法在Servlet被销毁之前执行，一般用于释放资源</strong>  <h4 id="解决Servlet配置问题"><a href="#解决Servlet配置问题" class="headerlink" title="解决Servlet配置问题"></a>解决Servlet配置问题</h4></li><li>Servlet3.0之后，支持注解配置，可以不需要web.xml  <img src="/2019/09/11/Demo33/02.jpg"></li><li>步骤：  </li></ul><p>1.创建JavaEE的项目,选择Servlet的版本，3.0以上，可以不创建web.xml<br>2.定义一个类，实现Servlet接口<br>3.复写方法<br><strong>4.在类上使用@WebServlet注解，进行配置</strong><br><code>@WebServlet(urlPatterns = &quot;/资源路径&quot;)</code>  </p><h4 id="IDEA与Tamcat的相关配置"><a href="#IDEA与Tamcat的相关配置" class="headerlink" title="IDEA与Tamcat的相关配置"></a>IDEA与Tamcat的相关配置</h4><ul><li>1.IDEA会为每一个tomcat部署的项目单独建立一份配置文件<br>查看控制台的输出log:Using CATALINA_BASE:   “C:\Users\LENOVO.IntelliJIdea2018.2\system\tomcat_Test”  </li><li>2.工作空间目录和Tomcat部署的web项目  <ul><li><strong>Tomcat真正访问的是“Tomcat部署的web项目，以我电脑为例 D:\IntelliJIDEA2018\Test\out\artifacts\TestDemo02_war_exploded”，Tomcat部署的web项目对应着工作空间项目的web目录下的所有资源，而且web-INFO下的classes对应的字节码文件是工作空间src下的Java文件被编译后放到里面的</strong>  </li><li><strong><em>WEB_INFO目录下的资源不能被浏览器直接访问，所以一般不把一些静态资源放到这下面</em></strong>  </li><li>在Tomcat如何断点调试<br>使用“小虫子”启动  <img src="/2019/09/11/Demo33/03.jpg"></li></ul></li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;概念：servlet applet,运行在服务器端的小程序,servlet就是一个接口，
      
    
    </summary>
    
    
      <category term="Servlet" scheme="https://Yogaguo.github.io/categories/Servlet/"/>
    
      <category term="Tomcat" scheme="https://Yogaguo.github.io/categories/Servlet/Tomcat/"/>
    
    
      <category term="servlet" scheme="https://Yogaguo.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Web相关知识入门</title>
    <link href="https://Yogaguo.github.io/2019/09/11/Demo2/"/>
    <id>https://Yogaguo.github.io/2019/09/11/Demo2/</id>
    <published>2019-09-11T09:07:56.000Z</published>
    <updated>2019-09-11T09:12:07.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web服务入门介绍"><a href="#Web服务入门介绍" class="headerlink" title="Web服务入门介绍"></a>Web服务入门介绍</h2><ul><li><p>web相关概念回顾</p></li><li><p>web服务器软件:Tomcat</p></li><li><p>Servlet入门学习  </p><h3 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h3></li><li><p>1.软件架构  </p><ul><li>1.C/S:客户端/服务器端    </li><li>2.B/S:浏览器/服务器端 (重点) </li></ul></li><li><p>2.资源分类  </p><ul><li>1.静态资源:所有用户访问后，得到的结果都是一样的,静态资源可以直接被浏览器解析 * 如:html,css,Javascript  </li><li>2.动态资源:每个用户访问相同资源后，得到的结果可能不一样 ,动态资源被访问后需要先转为静态资源，再返回给浏览器(Response) *如 servlet/jsp,php  </li></ul></li><li><p>3.网络通讯三要素  </p><ul><li>1.IP:电子设备在网络中的唯一标识 </li><li>2.端口:应用程序在计算机中的唯一标识 0-65535</li><li>3.传输协议:规定了数据传输的规范<ul><li>1.基础协议:  <ul><li>1.tcp:安全的协议，三次握手确认双方都在线，在进行传输 ，速度稍慢 </li><li>2.udp:不安全协议，速度快  <h3 id="web服务器软件"><a href="#web服务器软件" class="headerlink" title="web服务器软件"></a>web服务器软件</h3></li></ul></li></ul></li></ul></li><li><p>1.服务器：安装了服务器软件的计算机  </p></li><li><p>2.服务器软件:接受用户的请求，处理请求，做出响应  </p></li><li><p>web服务器软件：接受用户的请求，处理请求，做出响应   </p><ul><li>1.在web服务器软件中可以部署web项目，让用户通过浏览器来访问这些项目  </li><li>2.web容器  </li></ul></li><li><p>3.常见java相关的web服务器软件  </p><ul><li>1.webLogic:oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的  </li><li>2.webSphere:IBW公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的    </li><li>3.JBOSS:JBOSS公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的  </li><li>4.Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范(servlet/jsp),开源的，免费的  </li></ul></li><li><p>4.JavaEE:Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范  </p><h3 id="Tomcat-web服务器软件"><a href="#Tomcat-web服务器软件" class="headerlink" title="Tomcat:web服务器软件"></a>Tomcat:web服务器软件</h3></li><li><p>1.下载: <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">官网地址</a>  </p></li><li><p>2.安装: 解压压缩包 (<strong>注意：安装目录建议不要有中文和空格</strong>) </p></li><li><p>3.卸载: 删除目录就行  </p></li><li><p>4.启动:bin/startup.bat双击该文件  </p><ul><li>1.访问自己：浏览器输入：(<a href="http://localhost:8888)(我自己该的端口号，默认8080)" target="_blank" rel="noopener">http://localhost:8888)(我自己该的端口号，默认8080)</a> 回车访问  </li><li>2.访问别人:(http://别人ip:8080)  </li><li>3.可能遇到的问题:  <ul><li>1.黑窗口一闪而过：没有正确配置JAVA_HOME环境变量  </li><li>2.启动报错：<ul><li>1.暴力解决-&gt;找到占用的端口号，并且找到对应进程，杀死该进程.  </li><li>2.温柔解决:修改自身端口号,   conf/server.xml     服务器的主配置文件   <strong>注意：改动此文件时先备份，以防改错</strong>  <pre><code>&lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;       connectionTimeout=&quot;20000&quot;       redirectPort=&quot;8443&quot; /&gt;  </code></pre></li></ul></li></ul></li></ul></li><li><p>5.关闭:</p><ul><li>1.bin目录命令窗口直接敲  shutdown/catalina stop 二者都可以,或者直接双击shutdown文件</li></ul></li><li><p>6.配置:</p><ul><li>1.部署项目的方式：  <ul><li>1.直接将项目放到webapps目录下即可  <ul><li><ol><li>/hello:项目的访问路径—&gt;虚拟目录  </li></ol></li><li>2.简单部署：将项目打包成war包,再将war包放置到webapps目录下，war包会自动解压  </li></ul></li><li>1.配置conf/server.xml文件  </li><li>1.在conf\Catalina\localhost创建任意名称的xml文件，在文件中编写  </li></ul></li><li>1.静态项目和动态项目  <ul><li>1.目录结构  <ul><li>1.Java动态项目的目录结构  <ul><li>项目根目录  <ul><li>WEB-INF目录：  <ul><li>web.xml:web项目核心配置文件  </li><li>class目录：放置字节码文件  </li><li>lib目录：放置依赖的jar包  </li></ul></li></ul></li></ul></li></ul></li><li>将Tomcat集成到IDEA中，并且创建JavaEE的项目,部署项目  <ul><li>Run-&gt;Edit configurations-&gt;Templates-&gt;Tomcat server-&gt;Local  </li><li>配置Tomcat路径  </li><li><img src="!%5B%5D(http://ww1.sinaimg.cn/large/006VKolAly1g6dcz3t5ywj30lv043glj.jpg)" alt="如图">  </li><li>热部署：保证每次更新资源，Tomcat会自动启动</li><li><img src="!%5B%5D(http://ww1.sinaimg.cn/large/006VKolAly1g6dd6hai4nj30bc03ka9w.jpg)" alt>  </li><li></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web服务入门介绍&quot;&gt;&lt;a href=&quot;#Web服务入门介绍&quot; class=&quot;headerlink&quot; title=&quot;Web服务入门介绍&quot;&gt;&lt;/a&gt;Web服务入门介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;web相关概念回顾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;web服务器
      
    
    </summary>
    
    
      <category term="Servlet" scheme="https://Yogaguo.github.io/categories/Servlet/"/>
    
    
      <category term="servlet" scheme="https://Yogaguo.github.io/tags/servlet/"/>
    
  </entry>
  
</feed>
